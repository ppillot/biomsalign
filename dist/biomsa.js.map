{"version":3,"file":"biomsa.js","sources":["../src/utils/bitarray.ts","../src/align/params.ts","../src/sequence/sequence.ts","../src/utils/estring.ts","../src/align/align.ts","../src/sequence/profile.ts","../src/sequence/tree.ts","../src/align/progressive.alignment.ts","../src/utils/queue.ts","../src/align/noalign.ts","../src/index.ts"],"sourcesContent":["/**\n * @file Bit array\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\n * @author Paul Pillot <paulpillot@gmail.com>\n * @private\n */\n\n/**\n * Compute the Hamming weight of a 32-bit unsigned integer\n * @param  {Integer} v - a 32-bit unsigned integer\n * @return {Integer} the Hamming weight\n */\nexport function hammingWeight(v: number) {\n    // works with signed or unsigned shifts\n    v -= (v >>> 1) & 0x55555555;\n    v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);\n    return (((v + (v >>> 4)) & 0xf0f0f0f) * 0x1010101) >>> 24;\n}\n\n/**\n * Bit array\n *\n * Based heavily on https://github.com/lemire/FastBitSet.js\n * which is licensed under the Apache License, Version 2.0.\n */\nexport default class BitArray {\n    private _words: Uint32Array;\n    public length: number;\n\n    /**\n     * @param  {Integer} length - array length\n     * @param  {Boolean} [setAll] - initialize with true\n     */\n    constructor(length: number, setAll?: boolean) {\n        this.length = length;\n        this._words = new Uint32Array((length + 32) >>> 5);\n        if (setAll === true) {\n            this.setAll();\n        }\n    }\n\n    /**\n     * Get value at index\n     * @param  {Integer} index - the index\n     * @return {Boolean} value\n     */\n    get(index: number) {\n        return (this._words[index >>> 5] & (1 << index)) !== 0;\n    }\n\n    /**\n     * Set value at index to true\n     * @param  {Integer} index - the index\n     * @return {undefined}\n     */\n    set(index: number) {\n        this._words[index >>> 5] |= 1 << index;\n    }\n\n    /**\n     * Set value at index to false\n     * @param  {Integer} index - the index\n     * @return {undefined}\n     */\n    clear(index: number) {\n        this._words[index >>> 5] &= ~(1 << index);\n    }\n\n    /**\n     * Flip value at index\n     * @param  {Integer} index - the index\n     * @return {undefined}\n     */\n    flip(index: number) {\n        this._words[index >>> 5] ^= 1 << index;\n    }\n\n    _assignRange(start: number, end: number, value: boolean) {\n        if (end < start) return;\n        const words = this._words;\n        const wordValue = value === true ? 0xffffffff : 0;\n        const wordStart = start >>> 5;\n        const wordEnd = end >>> 5;\n        // set complete words when applicable\n        for (let k = wordStart; k < wordEnd; ++k) {\n            words[k] = wordValue;\n        }\n        // set parts of the range not spanning complete words\n        const startWord = wordStart << 5;\n        const endWord = wordEnd << 5;\n        if (value === true) {\n            if (end - start < 32) {\n                for (let i = start, n = end + 1; i < n; ++i) {\n                    words[i >>> 5] |= 1 << i;\n                }\n            } else {\n                for (let i = start, n = startWord; i < n; ++i) {\n                    words[i >>> 5] |= 1 << i;\n                }\n                for (let i = endWord, n = end + 1; i < n; ++i) {\n                    words[i >>> 5] |= 1 << i;\n                }\n            }\n        } else {\n            if (end - start < 32) {\n                for (let i = start, n = end + 1; i < n; ++i) {\n                    words[i >>> 5] &= ~(1 << i);\n                }\n            } else {\n                for (let i = start, n = startWord; i < n; ++i) {\n                    words[i >>> 5] &= ~(1 << i);\n                }\n                for (let i = endWord, n = end + 1; i < n; ++i) {\n                    words[i >>> 5] &= ~(1 << i);\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Set bits of the given range\n     * @param {Integer} start - start index\n     * @param {Integer} end - end index\n     * @return {BitArray} this object\n     */\n    setRange(start: number, end: number) {\n        return this._assignRange(start, end, true);\n    }\n\n    /**\n     * Clear bits of the given range\n     * @param {Integer} start - start index\n     * @param {Integer} end - end index\n     * @return {BitArray} this object\n     */\n    clearRange(start: number, end: number) {\n        return this._assignRange(start, end, false);\n    }\n\n    /**\n     * Set bits at all given indices\n     * @param {...Integer} arguments - indices\n     * @return {Boolean} this object\n     */\n    setBits(...indices: number[]) {\n        const words = this._words;\n        const n = indices.length;\n        for (let i = 0; i < n; ++i) {\n            const index = indices[i];\n            words[index >>> 5] |= 1 << index;\n        }\n        return this;\n    }\n\n    /**\n     * Clear bits at all given indices\n     * @param {...Integer} arguments - indices\n     * @return {Boolean} this object\n     */\n    clearBits(...indices: number[]) {\n        const words = this._words;\n        const n = indices.length;\n        for (let i = 0; i < n; ++i) {\n            const index = indices[i];\n            words[index >>> 5] &= ~(1 << index);\n        }\n        return this;\n    }\n\n    /**\n     * Set all bits of the array\n     * @return {BitArray} this object\n     */\n    setAll() {\n        return this._assignRange(0, this.length - 1, true);\n    }\n\n    /**\n     * Clear all bits of the array\n     * @return {BitArray} this object\n     */\n    clearAll() {\n        return this._assignRange(0, this.length - 1, false);\n    }\n\n    /**\n     * Flip all the values in the array\n     * @return {BitArray} this object\n     */\n    flipAll() {\n        const count = this._words.length;\n        const words = this._words;\n        const bs = 32 - (this.length % 32);\n        for (let k = 0; k < count - 1; ++k) {\n            words[k] = ~words[k];\n        }\n        words[count - 1] = ~(words[count - 1] << bs) >>> bs;\n        return this;\n    }\n\n    _isRangeValue(start: number, end: number, value: boolean) {\n        if (end < start) return;\n        const words = this._words;\n        const wordValue = value === true ? 0xffffffff : 0;\n        const wordStart = start >>> 5;\n        const wordEnd = end >>> 5;\n        // set complete words when applicable\n        for (let k = wordStart; k < wordEnd; ++k) {\n            if (words[k] !== wordValue) return false;\n        }\n        // set parts of the range not spanning complete words\n        if (end - start < 32) {\n            for (let i = start, n = end + 1; i < n; ++i) {\n                if (!!(words[i >>> 5] & (1 << i)) !== value) return false;\n            }\n        } else {\n            const startWord = wordStart << 5;\n            const endWord = wordEnd << 5;\n            for (let i = start, n = startWord << 5; i < n; ++i) {\n                if (!!(words[i >>> 5] & (1 << i)) !== value) return false;\n            }\n            for (let i = endWord, n = end + 1; i < n; ++i) {\n                if (!!(words[i >>> 5] & (1 << i)) !== value) return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Test if bits in given range are set\n     * @param {Integer} start - start index\n     * @param {Integer} end - end index\n     * @return {BitArray} this object\n     */\n    isRangeSet(start: number, end: number) {\n        return this._isRangeValue(start, end, true);\n    }\n\n    /**\n     * Test if bits in given range are clear\n     * @param {Integer} start - start index\n     * @param {Integer} end - end index\n     * @return {BitArray} this object\n     */\n    isRangeClear(start: number, end: number) {\n        return this._isRangeValue(start, end, false);\n    }\n\n    /**\n     * Test if all bits in the array are set\n     * @return {Boolean} test result\n     */\n    isAllSet() {\n        return this._isRangeValue(0, this.length - 1, true);\n    }\n\n    /**\n     * Test if all bits in the array are clear\n     * @return {Boolean} test result\n     */\n    isAllClear() {\n        return this._isRangeValue(0, this.length - 1, false);\n    }\n\n    /**\n     * Test if bits at all given indices are set\n     * @param {...Integer} arguments - indices\n     * @return {Boolean} test result\n     */\n    isSet(...indices: number[]) {\n        const words = this._words;\n        const n = indices.length;\n        for (let i = 0; i < n; ++i) {\n            const index = indices[i];\n            if ((words[index >>> 5] & (1 << index)) === 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Test if bits at all given indices are clear\n     * @param {...Integer} arguments - indices\n     * @return {Boolean} test result\n     */\n    isClear(...indices: number[]) {\n        const words = this._words;\n        const n = indices.length;\n        for (let i = 0; i < n; ++i) {\n            const index = indices[i];\n            if ((words[index >>> 5] & (1 << index)) !== 0) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Test if two BitArrays are identical in all their values\n     * @param {BitArray} otherBitarray - the other BitArray\n     * @return {Boolean} test result\n     */\n    isEqualTo(otherBitarray: BitArray) {\n        const words1 = this._words;\n        const words2 = otherBitarray._words;\n        const count = Math.min(words1.length, words2.length);\n        for (let k = 0; k < count; ++k) {\n            if (words1[k] !== words2[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * How many set bits?\n     * @return {Integer} number of set bits\n     */\n    getSize() {\n        const count = this._words.length;\n        const words = this._words;\n        let size = 0;\n        for (let i = 0; i < count; ++i) {\n            size += hammingWeight(words[i]);\n        }\n        return size;\n    }\n\n    /**\n     * Calculate difference betwen this and another bit array.\n     * Store result in this object.\n     * @param  {BitArray} otherBitarray - the other bit array\n     * @return {BitArray} this object\n     */\n    difference(otherBitarray: BitArray) {\n        const words1 = this._words;\n        const words2 = otherBitarray._words;\n        const count = Math.min(words1.length, words2.length);\n        for (let k = 0; k < count; ++k) {\n            words1[k] = words1[k] & ~words2[k];\n        }\n        for (let k = words1.length; k < count; ++k) {\n            words1[k] = 0;\n        }\n        return this;\n    }\n\n    /**\n     * Calculate union betwen this and another bit array.\n     * Store result in this object.\n     * @param  {BitArray} otherBitarray - the other bit array\n     * @return {BitArray} this object\n     */\n    union(otherBitarray: BitArray) {\n        const words1 = this._words;\n        const words2 = otherBitarray._words;\n        const count = Math.min(words1.length, words2.length);\n        for (let k = 0; k < count; ++k) {\n            words1[k] |= words2[k];\n        }\n        for (let k = words1.length; k < count; ++k) {\n            words1[k] = 0;\n        }\n        return this;\n    }\n\n    /**\n     * Calculate intersection betwen this and another bit array.\n     * Store result in this object.\n     * @param  {BitArray} otherBitarray - the other bit array\n     * @return {BitArray} this object\n     */\n    intersection(otherBitarray: BitArray) {\n        const words1 = this._words;\n        const words2 = otherBitarray._words;\n        const count = Math.min(words1.length, words2.length);\n        for (let k = 0; k < count; ++k) {\n            words1[k] &= words2[k];\n        }\n        for (let k = words1.length; k < count; ++k) {\n            words1[k] = 0;\n        }\n        return this;\n    }\n\n    /**\n     * Test if there is any intersection betwen this and another bit array.\n     * @param  {BitArray} otherBitarray - the other bit array\n     * @return {Boolean} test result\n     */\n    intersects(otherBitarray: BitArray) {\n        const words1 = this._words;\n        const words2 = otherBitarray._words;\n        const count = Math.min(words1.length, words2.length);\n        for (let k = 0; k < count; ++k) {\n            if ((words1[k] & words2[k]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Calculate the number of bits in common betwen this and another bit array.\n     * @param  {BitArray} otherBitarray - the other bit array\n     * @return {Integer} size\n     */\n    getIntersectionSize(otherBitarray: BitArray) {\n        const words1 = this._words;\n        const words2 = otherBitarray._words;\n        const count = Math.min(words1.length, words2.length);\n        let size = 0;\n        for (let k = 0; k < count; ++k) {\n            size += hammingWeight(words1[k] & words2[k]);\n        }\n        return size;\n    }\n\n    /**\n     * Calculate intersection betwen this and another bit array.\n     * Store result in a new bit array.\n     * @param  {BitArray} otherBitarray - the other bit array\n     * @return {BitArray} the new bit array\n     */\n    makeIntersection(otherBitarray: BitArray) {\n        const words1 = this._words;\n        const words2 = otherBitarray._words;\n        const count = Math.min(words1.length, words2.length);\n        const wordsA = new Uint32Array(count);\n        const intersection = Object.create(BitArray.prototype);\n        intersection._words = wordsA;\n        intersection.length = Math.min(this.length, otherBitarray.length);\n        for (let k = 0; k < count; ++k) {\n            wordsA[k] = words1[k] & words2[k];\n        }\n        return intersection;\n    }\n\n    /**\n     * Iterate over all set bits in the array\n     * @param  {function( index: Integer, i: Integer )} callback - the callback\n     * @return {undefined}\n     */\n    forEach(callback: (index: number, i: number) => any) {\n        const count = this._words.length;\n        const words = this._words;\n        let i = 0;\n        for (let k = 0; k < count; ++k) {\n            let w = words[k];\n            while (w !== 0) {\n                const t = w & -w;\n                const index = (k << 5) + hammingWeight(t - 1);\n                callback(index, i);\n                w ^= t;\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * Get an array with the set bits\n     * @return {Array} bit indices\n     */\n    toArray() {\n        const words = this._words;\n        const answer = new Array(this.getSize());\n        const count = this._words.length;\n        let pos = 0;\n        for (let k = 0; k < count; ++k) {\n            let w = words[k];\n            while (w !== 0) {\n                const t = w & -w;\n                answer[pos++] = (k << 5) + hammingWeight(t - 1);\n                w ^= t;\n            }\n        }\n        return answer;\n    }\n\n    toString() {\n        return '{' + this.toArray().join(',') + '}';\n    }\n\n    toSeleString() {\n        const sele = this.toArray().join(',');\n        return sele ? '@' + sele : 'NONE';\n    }\n\n    /**\n     * Clone this object\n     * @return {BitArray} the cloned object\n     */\n    clone() {\n        const clone = Object.create(BitArray.prototype);\n        clone.length = this.length;\n        clone._words = new Uint32Array(this._words);\n        return clone;\n    }\n}\n","/**\n * @file params\n * @author Paul Pillot <paul.pillot@libmol.org>\n * @license MIT\n * @copyright 2020\n */\n\nimport { TAlignOpt } from \"..\";\n\nexport enum SEQUENCE_TYPE {\n    PROTEIN,\n    NUCLEIC,\n    UNSET\n}\n\nexport const DEBUG = false;\nexport const DEFAULT_GAP_CHAR = '-';\n\n// const BLOSUM62 = {\n//     matrix: [\n//         //    A   C   D   E   F   G   H   I   K   L   M   N   P   Q   R   S   T   V   W   Y\n//         [4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2, 0], // A\n//         [0, 9, -3, -4, -2, -3, -3, -1, -3, -1, -1, -3, -3, -3, -3, -1, -1, -1, -2, -2, 0], // C\n//         [-2, -3, 6, 2, -3, -1, -1, -3, -1, -4, -3, 1, -1, 0, -2, 0, -1, -3, -4, -3, 0], // D\n//         [-1, -4, 2, 5, -3, -2, 0, -3, 1, -3, -2, 0, -1, 2, 0, 0, -1, -2, -3, -2, 0], // E\n//         [-2, -2, -3, -3, 6, -3, -1, 0, -3, 0, 0, -3, -4, -3, -3, -2, -2, -1, 1, 3, 0], // F\n//         [0, -3, -1, -2, -3, 6, -2, -4, -2, -4, -3, 0, -2, -2, -2, 0, -2, -3, -2, -3, 0], // G\n//         [-2, -3, -1, 0, -1, -2, 8, -3, -1, -3, -2, 1, -2, 0, 0, -1, -2, -3, -2, 2, 0], // H\n//         [-1, -1, -3, -3, 0, -4, -3, 4, -3, 2, 1, -3, -3, -3, -3, -2, -1, 3, -3, -1, 0], // I\n//         [-1, -3, -1, 1, -3, -2, -1, -3, 5, -2, -1, 0, -1, 1, 2, 0, -1, -2, -3, -2, 0], // K\n//         [-1, -1, -4, -3, 0, -4, -3, 2, -2, 4, 2, -3, -3, -2, -2, -2, -1, 1, -2, -1, 0], // L\n//         [-1, -1, -3, -2, 0, -3, -2, 1, -1, 2, 5, -2, -2, 0, -1, -1, -1, 1, -1, -1, 0], // M\n//         [-2, -3, 1, 0, -3, 0, 1, -3, 0, -3, -2, 6, -2, 0, 0, 1, 0, -3, -4, -2, 0], // N\n//         [-1, -3, -1, -1, -4, -2, -2, -3, -1, -3, -2, -2, 7, -1, -2, -1, -1, -2, -4, -3, 0], // P\n//         [-1, -3, 0, 2, -3, -2, 0, -3, 1, -2, 0, 0, -1, 5, 1, 0, -1, -2, -2, -1, 0], // Q\n//         [-1, -3, -2, 0, -3, -2, 0, -3, 2, -2, -1, 0, -2, 1, 5, -1, -1, -3, -3, -2, 0], // R\n//         [1, -1, 0, 0, -2, 0, -1, -2, 0, -2, -1, 1, -1, 0, -1, 4, 1, -2, -3, -2, 0], // S\n//         [0, -1, -1, -1, -2, -2, -2, -1, -1, -1, -1, 0, -1, -1, -1, 1, 5, 0, -2, -2, 0], // T\n//         [0, -1, -3, -2, -1, -3, -3, 3, -2, 1, 1, -3, -2, -2, -3, -2, 0, 4, -3, -1, 0], // V\n//         [-3, -2, -4, -3, 1, -2, -2, -3, -3, -2, -1, -4, -4, -2, -3, -3, -2, -3, 11, 2, 0], // W\n//         [-2, -2, -3, -2, 3, -3, 2, -1, -2, -1, -1, -2, -3, -1, -2, -2, -2, -1, 2, 7, 0], // Y\n//         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // *\n//     ],\n//     gapOP: -11,\n//     gapEP: -1,\n// };\n\nconst VTML240 = {\n    matrix: [\n        //  A    C    D    E    F    G    H    I    K    L    M    N    P    Q    R    S    T    V    W    Y    X\n        [  58,  23, -12,  -7, -44,  10, -23, -14, -14, -27, -17,  -8,   1,  -9, -22,  23,  15,   5, -74, -45,   0], // A\n        [  23, 224, -67, -63, -50, -30, -29,   1, -56, -41,  -6, -33, -44, -53, -43,  15,   2,  18, -93,  -6,   0], // C\n        [ -12, -67, 111,  59, -104, -4,   4, -84,   6, -88, -65,  48, -13,  18, -29,   5,  -7, -63,-105, -73,   0], // D\n        [  -7, -63,  59,  85, -83, -17,  -1, -63,  25, -60, -47,  15, -12,  40,  -8,   1,  -7, -47,-108, -51,   0], // E\n        [ -44, -50,-104, -83, 144, -93,   4,  12, -74,  36,  30, -64, -67, -56, -65, -43, -41,  -3,  63, 104,   0], // F\n        [  10, -30,  -4, -17, -93, 140, -32, -95, -27, -91, -75,   4, -36, -29, -32,   5, -26, -68, -80, -79,   0], // G\n        [ -23, -29,   4,  -1,   4, -32, 137, -50,   6, -37, -42,  21, -23,  27,  19,  -4, -12, -44, -13,  48,   0], // H\n        [ -14,   1, -84, -63,  12, -95, -50,  86, -53,  53,  47, -62, -60, -47, -55, -43,  -8,  69, -27, -24,   0], // I\n        [ -14, -56,   6,  25, -74, -27,   6, -53,  75, -48, -30,  13, -12,  34,  68,  -3,  -4, -44, -71, -49,   0], // K\n        [ -27, -41, -88, -60,  36, -91, -37,  53, -48,  88,  62, -63, -48, -36, -48, -47, -25,  36, -11,  -4,   0], // L\n        [ -17,  -6, -65, -47,  30, -75, -42,  47, -30,  62, 103, -45, -54, -21, -31, -35,  -9,  31, -46, -20,   0], // M\n        [  -8, -33,  48,  15, -64,   4,  21, -62,  13, -63, -45,  89, -25,  12,   2,  22,  10, -51, -79, -29,   0], // N\n        [   1, -44, -13, -12, -67, -36, -23, -60, -12, -48, -54, -25, 160,  -6, -20,   5, -12, -42, -76, -83,   0], // P\n        [  -9, -53,  18,  40, -56, -29,  27, -47,  34, -36, -21,  12,  -6,  75,  34,   1,  -4, -37, -92, -48,   0], // Q\n        [ -22, -43, -29,  -8, -65, -32,  19, -55,  68, -48, -31,   2, -20,  34, 113, -10, -14, -49, -58, -39,   0], // R\n        [  23,  15,   5,   1, -43,   5,  -4, -43,  -3, -47, -35,  22,   5,   1, -10,  53,  32, -28, -62, -31,   0], // S\n        [  15,   2,  -7,  -7, -41, -26, -12,  -8,  -4, -25,  -9,  10, -12,  -4, -14,  32,  68,   0, -87, -40,   0], // T\n        [   5,  18, -63, -47,  -3, -68, -44,  69, -44,  36,  31, -51, -42, -37, -49, -28,   0,  74, -61, -32,   0], // V\n        [ -74, -93,-105,-108,  63, -80, -13, -27, -71, -11, -46, -79, -76, -92, -58, -62, -87, -61, 289,  81,   0], // W\n        [ -45,  -6, -73, -51, 104, -79,  48, -24, -49,  -4, -20, -29, -83, -48, -39, -31, -40, -32,  81, 162,   0], // Y\n        [   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0], // X\n    ],\n    center: 22,\n    gapOP: -300,\n};\n\nconst BLASTZ = {\n    matrix: [\n        //\tA\t\tC\t\tG\t\tT\n        [ 91,   -114,     -31,   -123],\n        [-114,   100,    -125,    -31],\n        [ -31,  -125,     100,   -114],\n        [-123,   -31,    -114,     91],\n    ],\n    gapOP: -400,\n    gapEP: -60,\n    center: 120,\n};\n\n/**\n * Recursively adds a constant center to all the matrix values\n * @param {Array} matrix Scoring matrix\n * @param {number} center half gap penalty (see Edgar's MUSCLE for details on\n * \t\t\tthis optimization). In a few words, adding a constant half penalty\n * \t\t\tto all substitution scores -i.e. matches-, makes it so that we\n * \t\t\tcan skip to substract penalties when extending a gap as it will\n * \t\t\tbe comparatively lower scored).\n */\nfunction addCenter(matrix: number[][], center: number) {\n    return matrix.map((row) => row.map((val) => val + center));\n}\n\nexport type TAlignmentParam = ReturnType<typeof getAlignmentParameters>\n\nexport function getAlignmentParameters(pTypeSeq: SEQUENCE_TYPE, opt?: Partial<TAlignOpt>) {\n    const m = (pTypeSeq === SEQUENCE_TYPE.PROTEIN) ? VTML240 : BLASTZ;\n\n    let lMatrix = opt?.matrix ?? m.matrix;\n    let lCenter = opt?.gapextend ? - opt.gapextend * 2 : m.center;\n\n    const scoringMatrix = addCenter(\n        lMatrix,\n        lCenter\n    );\n    const gapOP: number = opt?.gapopen ?? m.gapOP;\n\n    return {\n        type: pTypeSeq,\n        scoringMatrix,\n        gapOP,\n        abSize: (pTypeSeq === SEQUENCE_TYPE.PROTEIN) ? 20 : 4\n    };\n}","/**\n * @file utils\n * @author Paul Pillot <paul.pillot@libmol.org>\n * @license MIT\n * @copyright 2020\n */\nimport BitArray from '../utils/bitarray';\nimport { DEBUG, SEQUENCE_TYPE } from '../align/params';\nimport Log from '../utils/logger';\n\nexport type TSequence = {\n    /** Sequence as a string */\n    rawSeq: string;\n    /** Sequence encoded as a number array */\n    encodedSeq: Uint8Array;\n    /** Sequence encoded as a number array in a compressed alphabet (Dayhoff) */\n    compressedSeq: Uint8Array;\n    /** Sequence type enum (PROTEIN or NUCLEIC) */\n    type: SEQUENCE_TYPE;\n};\n\nconst regAmino    = /^[ACGTRNDEQHILKMFPSWYV]+$/;\nconst regExtNuc   = /^[ABCDGHKMNRSTUVWY]+$/i;\nconst regExtAmino = /^[ABCGTRNDEQHIJLKMFPSWYUVXZ]+$/i;\nconst regNotRNA   = /[^ACGU]/i;\nconst regNotDNA   = /[^ACGT]/i;\nconst CODE_NOT_FOUND = 255;\n\n/**\n * Guess the type of sequence from its raw content\n * @param {string} seq sequence to guess the type from\n */\nexport function getSequenceType(seq: string) {\n\n    if (!regNotRNA.test(seq) || !regNotDNA.test(seq)) {\n        return SEQUENCE_TYPE.NUCLEIC\n    };\n\n    const isExtendedNuc = regExtNuc.test(seq);\n    const isAmino = regAmino.test(seq);\n\n    if (isAmino && !isExtendedNuc) return SEQUENCE_TYPE.PROTEIN;\n\n    if (isAmino && isExtendedNuc) return guessSequenceType(seq);\n\n    if (regExtAmino.test(seq)) return SEQUENCE_TYPE.PROTEIN;\n\n    throw new Error('Unrecognized sequence type: ' + seq);\n}\n\nfunction guessSequenceType (seq: string) {\n    const SAMPLE_SIZE = 100;\n    let lNucScore = 0;\n    const LEN = Math.min(seq.length, SAMPLE_SIZE);\n\n    for (let i = 0; i < LEN; i++) {\n        switch (seq[i]) {\n            case 'A':\n            case 'T':\n            case 'U':\n            case 'G':\n            case 'C':\n            case 'N':\n                lNucScore ++;\n        }\n    }\n\n    if (lNucScore / LEN > Math.SQRT1_2) return SEQUENCE_TYPE.NUCLEIC;\n\n    return SEQUENCE_TYPE.PROTEIN;\n}\n\n/**\n * Index aa codes based on ASCII code\n */\nexport const aaToNum = new Uint8Array(96);\naaToNum.fill(CODE_NOT_FOUND);\naaToNum[65] = 0; // A\naaToNum[67] = 1; // C\naaToNum[68] = 2; // D\naaToNum[69] = 3; // E\naaToNum[70] = 4; // F\naaToNum[71] = 5; // G\naaToNum[72] = 6; // H\naaToNum[73] = 7; // I\naaToNum[75] = 8; // K\naaToNum[76] = 9; // L\naaToNum[77] = 10; // M\naaToNum[78] = 11; // N\naaToNum[80] = 12; // P\naaToNum[81] = 13; // Q\naaToNum[82] = 14; // R\naaToNum[83] = 15; // S\naaToNum[84] = 16; // T\naaToNum[86] = 17; // V\naaToNum[87] = 18; // W\naaToNum[89] = 19; // Y\naaToNum[95] = 20; // _\n\n/**\n * Index nucleotides codes based on ASCII\n */\nexport const nucToNum = new Uint8Array(96);\nnucToNum.fill(CODE_NOT_FOUND);\nnucToNum[65] = 0; // A\nnucToNum[67] = 1; // C\nnucToNum[71] = 2; // G\nnucToNum[84] = 3; // T\nnucToNum[85] = 3; // U, uracile aligns with thymine\n\n/**\n * Encode sequence string as a number array. This is paramount to extract\n * substitution scores in O(1) time instead of O(ln) in the innermost loop.\n *\n * @export\n * @param {string} seq\n * @param {SEQUENCE_TYPE} type\n * @returns {number[]}\n */\nexport function encodeSeqToNum(seq: string, type: SEQUENCE_TYPE) {\n    const encodedTab = new Uint8Array(seq.length);\n    const convTable = type === SEQUENCE_TYPE.PROTEIN ? aaToNum : nucToNum;\n    let lEncoding = 0;\n\n    for (let i = 0, imax = seq.length; i < imax; i++) {\n        lEncoding = convTable[seq.charCodeAt(i)];\n        if (lEncoding === CODE_NOT_FOUND) lEncoding = setRandomCode(seq[i], type);\n\n        encodedTab[i] =  lEncoding;\n    }\n\n    return encodedTab;\n}\n\n/**\n * Interpolates ambiguous letters in sequences by picking randomly a standard\n * residue amongst the possible choices.\n * @param letter\n * @param type\n * @returns\n */\nfunction setRandomCode(letter: string, type: SEQUENCE_TYPE) {\n    const lRand = Math.floor(Math.random() * 100);\n    switch (type) {\n        case SEQUENCE_TYPE.NUCLEIC:\n            switch (letter) {\n                case 'M': return [0, 1][lRand % 2]; // A or C (amino)\n                case 'R': return [0, 2][lRand % 2]; // A or G (purine)\n                case 'W': return [0, 3][lRand % 2]; // A or T (weak)\n                case 'S': return [1, 2][lRand % 2]; // C or G (strong)\n                case 'Y': return [1, 3][lRand % 2]; // C or T (pyrimidine)\n                case 'K': return [2, 3][lRand % 2]; // G or T (keto)\n                case 'V': return [0, 1, 2][lRand % 3]; // A or C or G\n                case 'H': return [0, 1, 3][lRand % 3]; // A or C or T\n                case 'D': return [0, 2, 3][lRand % 3]; // A or G or T\n                case 'B': return [1, 2, 3][lRand % 3]; // C or G or T\n                case 'N': // passthrough intentional\n                default: return lRand % 4;\n            }\n\n        case SEQUENCE_TYPE.PROTEIN:\n        default:\n            switch (letter) {\n                case 'B': return [2, 11][lRand % 2]; // Asx\n                case 'Z': return [3, 13][lRand % 2]; // Glx\n                case 'J': return [7, 9 ][lRand % 2]; // Xle (Leu or Ile)\n                case 'U': // passtrhough intentional    Selenocysteine\n                case 'X': // passthrough intentional\n                default: return lRand % 20;\n            }\n    }\n}\n\n/**\n * Converts a proteic sequence to Dayhoff compressed alphabet. This increases\n * the probability of matches between divergent sequences by reducing the\n * number of combinations (20 amino acids to 6 symbols)\n *\n * @export\n * @param {number[]} encodedSeq Sequence encoded as a number array\n * @returns {number[]} compressed sequence encoded as a number array\n */\nexport function compressToDayhoff(encodedSeq: Uint8Array) {\n    const compressedSeq = encodedSeq.map((val) => toDayhoff[val]);\n    return compressedSeq;\n}\n\nconst toDayhoff = [\n    0, // A -> A\n    1, // C -> B\n    2, // D -> C\n    2, // E -> C\n    3, // F -> D\n    0, // G -> A\n    4, // H -> E\n    5, // I -> F\n    4, // K -> E\n    5, // L -> F\n    5, // M -> F\n    2, // N -> C\n    0, // P -> A\n    2, // Q -> C\n    4, // R -> E\n    0, // S -> A\n    0, // T -> A\n    5, // V -> F\n    3, // W -> D\n    3, // Y -> D\n];\n\nexport function distanceMatrix(tabSeq: TSequence[]) {\n    // A 6-tuple in the Dayhoff alphabet can result in 6^6 combinations.\n    // A 6-tuple in the nucleic alphabet can result in 4^6 combinations.\n    // To compute a distance between sequences, we evaluate how many 6-tuples\n    // they have in common. To speed-up this process, we consider only a binary\n    // comparison, i.e. does the tuple exists in the sequence or not (we ignore\n    // how many time it actually occurs, which is a limitation of this method\n    // for sequences with low complexity).\n\n    // Make the 6/4-kmer bitsets\n    const isProtein = tabSeq[0].type === SEQUENCE_TYPE.PROTEIN;\n    const alphabetSize = isProtein ? 6 : 4;\n    const bitsetLength = Math.pow(alphabetSize, 6);\n    const lKmer = tabSeq.map((seq) => {\n        const bitset = new BitArray(bitsetLength);\n        const seqAsNum = isProtein ? seq.compressedSeq : seq.encodedSeq;\n\n        // Value for a tuple is 1st letter + 6*2nd letter + 36*3rd letter...\n\n        let tupleval = 0;\n        for (let i = 0; i <= 5; i++ ) {\n            tupleval += seqAsNum[i] * Math.pow(alphabetSize, i);\n        }\n        bitset.set(tupleval);\n\n        // Compute next tuple from previous one\n\n        const topLetterFactor = Math.pow(alphabetSize, 5);\n        for (let i = 6, imax = seqAsNum.length; i < imax; i++) {\n            // remove lowest letter from tuple\n            tupleval -= seqAsNum[i - 6];\n\n            // shift value by 6\n\n            tupleval /= 6;\n\n            // add highest letter to tuple\n            tupleval += seqAsNum[i] * topLetterFactor;\n\n            bitset.set(tupleval);\n        }\n\n        return bitset;\n    });\n\n    if (DEBUG) Log.add('K-mer bitset computation');\n\n    // compute distance matrix values\n\n    const l = tabSeq.length;\n    const distTab: number[][] = tabSeq.map(() => []);\n    let lKmerI: BitArray;\n    let lSeqILen: number;\n    let lDistance: number;\n\n    for (let i = 0; i < l; i++) {\n        distTab[i][i] = 0;\n        lKmerI = lKmer[i];\n        lSeqILen = tabSeq[i].compressedSeq.length;\n\n        for (let j = i + 1; j < l; j++) {\n            lDistance = 1 - lKmerI.getIntersectionSize(lKmer[j]) / lSeqILen;\n            distTab[j][i] = distTab[i][j] = lDistance;\n        }\n\n    }\n\n    if (DEBUG) Log.add('K-mer distance computation');\n    return distTab;\n}\n\nexport function sortMSA<K>(msa: K[], order: number[]): K[] {\n    let lSorted = order.slice();\n    order.forEach((v, k) => lSorted[v] = k)\n    return lSorted.map(v => msa[v]);\n}\n\nconst dayhoffPams = [\n    195, /* 75.0% observed d; 195 PAMs estimated = 195% estimated d */\n    196, /* 75.1% observed d; 196 PAMs estimated */\n    197, 198, 199, 200, 200, 201, 202, 203,\n    204, 205, 206, 207, 208, 209, 209, 210, 211, 212,\n    213, 214, 215, 216, 217, 218, 219, 220, 221, 222,\n    223, 224, 226, 227, 228, 229, 230, 231, 232, 233,\n    234, 236, 237, 238, 239, 240, 241, 243, 244, 245,\n    246, 248, 249, 250, /* 250 PAMs = 80.3% observed d */\n    252, 253, 254, 255, 257, 258,\n    260, 261, 262, 264, 265, 267, 268, 270, 271, 273,\n    274, 276, 277, 279, 281, 282, 284, 285, 287, 289,\n    291, 292, 294, 296, 298, 299, 301, 303, 305, 307,\n    309, 311, 313, 315, 317, 319, 321, 323, 325, 328,\n    330, 332, 335, 337, 339, 342, 344, 347, 349, 352,\n    354, 357, 360, 362, 365, 368, 371, 374, 377, 380,\n    383, 386, 389, 393, 396, 399, 403, 407, 410, 414,\n    418, 422, 426, 430, 434, 438, 442, 447, 451, 456,\n    461, 466, 471, 476, 482, 487, 493, 498, 504, 511,\n    517, 524, 531, 538, 545, 553, 560, 569, 577, 586,\n    595, 605, 615, 626, 637, 649, 661, 675, 688, 703,\n    719, 736, 754, 775, 796, 819, 845, 874, 907, 945, /* 92.9% observed; 945 PAMs */\n    988 /* 93.0% observed; 988 PAMs */\n];\n\n/**\n * Computes the ratio between the number of matches in both sequences and the shortest sequence length\n * @param   {string} [seqA='',] sequence A, may contain indels\n * @param   {string} seqB       sequence B, may contain indels\n * @returns {number} fractional identity between both sequences\n */\nfunction fractionalIdentity(seqA: string, seqB: string) {\n    seqA = seqA || '';\n    seqB = seqB || '';\n\n    var match = 0,\n        tokenA = '',\n        tokenB = '',\n        lA = 0,\n        lB = 0,\n        maxI = seqA.length;\n\n    for (var i = 0; i < maxI; i++) {\n        tokenA = seqA.charAt(i);\n        tokenB = seqB.charAt(i);\n\n        if ((tokenA === '-') || (tokenB === '-')) {\n            lA += (tokenA !== '-') ? 1 : 0;\n            lB += (tokenB !== '-') ? 1 : 0;\n            continue;\n        } else {\n            lA++;\n            lB++;\n            if (tokenA === tokenB) {\n                match++;\n            }\n        }\n    }\n    return match / Math.min(lA, lB);\n}\n\n\n/**\n * Compute distance matrix between aligned sequences from a MSA.\n * Corrects distances using Kimura method.\n */\nexport function distanceKimura (msa: string[]) {\n\n    const l = msa.length; // nb of sequences\n    const distMatrix = new Array(l); // matrix l x l\n    let dPctId = 0; // Percentage of Identity between sequences\n    let p = 0;      // Percentage of difference between sequences\n    let pIndex = 0; // When p > 0.75 Kimura correction is replaced by a lookup table at this index\n    let dk = 0;     // Computed distance\n\n    //parcours de la matrice\n    for (var i = 0; i < l; i++) {\n\n        if ( distMatrix[i] === undefined ) {\n            distMatrix[i] = new Array(l);\n        }\n\n        distMatrix[i][i] = 0;\n\n        for (var j = i + 1; j < l; j++) {\n\n            if (distMatrix[j] === undefined) {\n                distMatrix[j] = new Array(l);\n            } else if (distMatrix[i][j] !== undefined) {\n                continue;\n            }\n\n            //  \"As sequences diverge, there is an increasing probability of\n            // multiple mutations at a single site. To correct for this, we use\n            // the following distance estimate\" Edgar. BMC Bioinformatics 2004\n\n            dPctId = fractionalIdentity(msa[i], msa[j]);\n            p = 1 - dPctId;\n\n            // Kimura formula used for differences < 75%\n            if (p < 0.75) {\n\n                dk = - Math.log(1 - p - (p * p) / 5);\n                dk = Math.max(0, dk);   // clamp to 0 as the above can return -0!!!\n\n            } else if (p > 0.93) {\n                dk = 10;\n            } else {\n\n                pIndex = Math.floor((p - 0.75) * 1000 + 0.5);\n\n                if ((pIndex < 0) || (pIndex >= dayhoffPams.length)) {\n                    console.trace('Dayhoff parameter not found');\n                } else {\n                    dk = dayhoffPams[pIndex] / 100;\n                }\n\n            }\n            distMatrix[i][j] = dk;\n            distMatrix[j][i] = dk;\n        }\n    }\n\n    return distMatrix;\n};\n\nexport function makeSequence(seq: string, type?: SEQUENCE_TYPE): TSequence {\n    const lType = type ?? getSequenceType(seq);\n    const encodedSeq = encodeSeqToNum(seq, lType);\n    return {\n        rawSeq: seq,\n        encodedSeq,\n        compressedSeq: lType === SEQUENCE_TYPE.PROTEIN ? compressToDayhoff(encodedSeq) : encodedSeq,\n        type: lType,\n    };\n}","/**\n * @file estring.ts\n * @author Paul Pillot <paul.pillot@libmol.org>\n * @license MIT\n * @copyright 2021\n * @description E-strings (Edit strings) are operators that act on a string to\n * add insertion characters.\n * The follofing example is taken from MUSCLE (a) presentation:\n * Sequence: MQTIF\n * Estring: <3, -1, 2>\n * Transformation: MQT-IF\n * Positive integers are the counts of letters conserved in a fragment, negative\n * numbers are the counts of insertions.\n * Note that the sum of the positive numbers is the size of the initial string,\n * and the sum of the absolute values is the final size of the string.\n * The alignment of two sequences can be described by the operators that\n * transform the initial strings in 2 strings of same size.\n *\n * (a) Edgar, R.C. MUSCLE: a multiple sequence alignment method with reduced\n * time and space complexity. BMC Bioinformatics 5, 113 (2004).\n * https://doi.org/10.1186/1471-2105-5-113\n */\n\nimport { DEFAULT_GAP_CHAR } from \"../align/params\";\nimport { TSequence } from \"../sequence/sequence\";\n\ntype TAlignedSeqFormat = {\n    gapchar: string\n}\n\nexport function applyEstring (pSeqArr: TSequence[], pEstring: number[][], opt?: Partial<TAlignedSeqFormat>) {\n    let lGapchar = opt?.gapchar ?? DEFAULT_GAP_CHAR;\n    let lResp: string[] = [];\n    for (let i = 0; i < pSeqArr.length; i ++) {\n        lResp.push(estringTransform(pSeqArr[i].rawSeq, pEstring[i], { gapchar: lGapchar }));\n    }\n    return lResp;\n}\n\n/**\n * Edits a string such as a sequence, by inserting gap symbols based on the\n * content of and Edit string.\n *\n * @export\n * @param {string} text\n * @param {number[]} estring\n * @returns {string}    edited string\n */\nexport function estringTransform (text: string, estring: number[], opt: TAlignedSeqFormat) {\n    const lPieces: string[] = [];\n    const GAPCHAR = opt.gapchar;\n    let lPos = 0;   // cursor in text\n    for (let i = 0; i < estring.length; i++) {\n        let n = estring[i];\n        if (n < 0) {\n            lPieces.push(GAPCHAR.repeat(-n));\n        } else {\n            lPieces.push(text.substr(lPos, n));\n            lPos += n;\n        }\n    }\n    return lPieces.join('');\n}\n\n/**\n * returns an edit string equivalent to the composition of the two edit strings\n * passed as an argument\n *\n * @export\n * @param {number[]} estringB\n * @param {number[]} estringA\n * @returns {number[]}\n */\nexport function estringProduct (estringB: number[], estringA: number[]): number[] {\n    const lSteps: number[] = [0];\n    let lPosA = 0;\n    const lEstringA = estringA.slice(); // make copy, will be modified\n\n    // add new value in lSteps. Collapses tail value if they have same sign\n    function pushOperator (val: number) {\n        if ((val ^ lSteps[lSteps.length - 1]) >= 0) {    // same sign\n            lSteps[lSteps.length - 1] += val;\n        } else {    // opposite sign: new item in array\n            lSteps.push(val);\n        }\n    }\n\n    for (let i = 0; i < estringB.length; i++) {\n        let n = estringB[i];\n        if (n < 0) {\n            pushOperator(n);\n        } else {\n            while (n > 0 && lPosA < lEstringA.length) {\n                let lValA = lEstringA[lPosA];\n                if (lValA < 0) {\n                    if (n < -lValA) {\n                        lEstringA[lPosA] += n;\n                        pushOperator(-n);\n                        n = 0;\n                    } else {\n                        pushOperator(lValA);\n                        n += lValA;\n                        lPosA ++;\n                    }\n                } else {\n                    if (n < lValA) {\n                        lEstringA[lPosA] -= n;\n                        pushOperator(n);\n                        n = 0;\n                    } else {\n                        pushOperator(lValA);\n                        n -= lValA;\n                        lPosA ++;\n                    }\n                }\n            }\n        }\n    }\n\n    return lSteps;\n}\n\n/**\n * estringA and estringB are estrings that are applied independently to the\n * same sequence. For example a sequence X is aligned to a sequence A using the\n * estringA operator, and is aligned to a sequenceB using the estringB operator.\n * estringMerge computes an estring that adds to sequence X the necessary gaps\n * to align it both with sequence A and with sequence B. The main goal of this\n * computation is to avoid introducing gaps twice when they interrupt the same\n * segments of X while aligning with A and aligning with B.\n * X: MQTIF\n * A: MQQTIIF       B: MQVTIFE      A: MQQTIIF-\n * X: MQ-TI-F       X: MT-TIF-      X: MG-TI-F- <2,-1,2,-1,1,-1>\n *  <2,-1,2,-1,1>   <2,-1,3,-1>     B: MQVTI-FE\n *\n * @export\n * @param {number[]} estringA\n * @param {number[]} estringB\n * @returns\n */\nexport function estringMerge(estringA: number[], estringB: number[]) {\n    const lEstring: number[] = [];\n\n    let i = 0;\n    let j = 0;\n    let lValA = estringA[0];\n    let lValB = estringB[0];\n\n    while (i < estringA.length || j < estringB.length) {\n        if (lValA === lValB) {\n            lEstring.push(lValB);\n            lValA = estringA[++i];\n            lValB = estringB[++j];\n            continue;\n        }\n\n        if (Math.sign(lValA) === Math.sign(lValB)) {\n            if (lValA > 0) {\n                // positive signs: add length of smallest segment (next\n                // iteration will be gaps insertions)\n\n                if (lValA > lValB) {\n                    lEstring.push(lValB);\n                    lValA -= lValB;\n                    lValB = estringB[++j];\n                } else {\n                    lEstring.push(lValA);\n                    lValB -= lValA;\n                    lValA = estringA[++i];\n                }\n            } else {\n                // gap insertions at the same position. Insert the maximum\n                // number of gaps\n\n                lEstring.push(Math.min(lValA, lValB));\n                lValA = estringA[++i];\n                lValB = estringB[++j];\n            }\n\n            continue;\n        }\n\n        // opposite sign: insert gaps\n        if (lValA < 0 || lValB === undefined)  {\n            lEstring.push(lValA);\n            lValA = estringA[++i];\n            continue;\n        }\n\n        lEstring.push(lValB);\n        lValB = estringB[++j];\n    }\n\n    return lEstring;\n}\n\n/**\n * Computes estringC that can be combined with estringA in estringProduct() to\n * get estringB.\n * The use case is to apply to sequence A, a transformation to align it with\n * the profile sequence B/sequence C, knowing the estring that leads to the\n * final shape of sequence B and the estring that aligns sequence B to sequence\n * A.\n * Important: we assume that estringB contains estringA. This entails that there\n * is no continuous segment in estringB that can be longer than its homologous\n * continuous segment in estringA (there is no gap between residues from\n * applying estringA that is not found when applying estringB)\n * X: MQTIF\n * A: MQQTIIF       B: MQVTIFE      A: MQQTIIF-\n * X: MQ-TI-F       X: MT-TIF-      X: MG-TI-F- <2,-1,2,-1,1,-1>\n *  <2,-1,2,-1,1>   <2,-1,3,-1>     B: MQVTI-FE\n *\n * difference <2,-1,2,-1,1,-1> - <2,-1,3,-1> = <5,-1,2>\n * difference <2,-1,2,-1,1,-1> - <2,-1,2,-1,1> = <7,-1>\n * @export\n * @param {number[]} estringB\n * @param {number[]} estringA\n * @returns\n */\nexport function estringDifference (estringB: number[], estringA: number[]) {\n    const lEstring: number[] = [];\n    let i = 0;\n    let j = 0;\n    let lValA = estringA[0];\n    let lValB = estringB[0];\n    let lCurVal = 0;\n\n    while (i < estringA.length || j < estringB.length) {\n        lCurVal = lEstring[lEstring.length - 1];\n        if (lValA === lValB) {\n            // Common segment. Collapse with current segment or create new one.\n            if (lCurVal > 0) {\n                lEstring[lEstring.length - 1] = lCurVal + Math.abs(lValA);\n            } else {\n                lEstring.push(Math.abs(lValA));\n            }\n            lValA = estringA[++i];\n            lValB = estringB[++j];\n            continue;\n        }\n\n        if (Math.sign(lValA) === Math.sign(lValB)) {\n            if (lValA > 0) {\n                // positive sign. lValB can only be smaller than lValA\n                // (otherwise estringA contains gaps not accounted for in\n                // estringB)\n                if (lValB > lValA) return undefined;    // error\n\n                if (lCurVal > 0) {\n                    lEstring[lEstring.length - 1] = lCurVal + lValB;\n                } else {\n                    lEstring.push(lValB);\n                }\n                lValA -= lValB;\n                lValB = estringB[++j];\n                continue;\n            }\n\n            // negative sign. we keep as much as possible from string A\n\n            if (lValA > lValB) {    // take all lValA\n                if (lCurVal > 0) {\n                    lEstring[lEstring.length - 1] = lCurVal - lValA;\n                } else {\n                    lEstring.push(Math.abs(lValA));\n                }\n                lValA = estringA[++i];\n                lValB -= lValA;\n                continue;\n            } else {\n                // this shan't happen: estringB can't introduce less gaps than\n                // estringA does.\n                return undefined;\n            }\n\n        }\n\n        // opposite signs: if valB is negative, it introduces a gap that must\n        // be kept.\n        // if valB is positive, then estringA introduces a gap that is not in\n        // estringB, which is not possible.\n        if (lValB < 0) {\n            if (lCurVal < 0) {\n                lEstring[lEstring.length - 1] = lCurVal + lValB;\n            } else {\n                lEstring.push(lValB);\n            }\n            lValB = estringB[++j];\n        } else {\n            return undefined;\n        }\n    }\n\n    return lEstring;\n}\n\n/**\n * Edit strings catenation.\n *\n * @export\n * @param {number[]} estringA\n * @param {number[]} estringB\n * @returns {number[]}\n */\nexport function estringCat (estringA: number[], estringB: number[]) {\n    if (Math.sign(estringA[estringA.length - 1]) === Math.sign(estringB[0])) {\n        let lRet = [...estringA];\n        lRet[lRet.length - 1] += estringB[0];\n        lRet.push(...estringB.slice(1));    // avoid changing reference\n        return lRet;\n    }\n    return [...estringA, ...estringB];\n}\n\nexport const enum EPATH_2_STRING {\n    NO_REVERSE = 1\n};\n\nexport function epath2estring (epath: number[], opt = 0): number[] {\n    const lEstring: number[] = [];\n\n    let lAcc = 0;\n    let lVal = 0;\n    for (let i = 0; i < epath.length; i++) {\n        lVal = epath[i];\n        if ((lVal ^ lAcc) >= 0) lAcc += lVal;\n        else {\n            lEstring.push(lAcc);\n            lAcc = lVal;\n        }\n    }\n    lEstring.push(lAcc);\n    if (lEstring[0] === 0) lEstring.shift();\n\n        // Usually, the path comes from a traceback matrix and must be reversed\n\n    if (!(opt & EPATH_2_STRING.NO_REVERSE)) lEstring.reverse();\n\n    return lEstring;\n}\n\nexport function estringLength (estring: number[]): number {\n    let lSize = 0;\n    let lVal = 0;\n    for (let i = 0; i < estring.length; i++) {\n        lVal = estring[i];\n        lSize += lVal < 0 ? - lVal : lVal;\n    }\n    return lSize;\n}\n\nexport function estringCountPositive (estring: number[]) {\n    let lCount = 0;\n    let lVal = 0;\n    for (let i = 0; i < estring.length; i++) {\n        lVal = estring[i];\n        if (lVal < 0) continue;\n        lCount += lVal;\n    }\n    return lCount;\n}\n\n/**\n * Convert an Edit string to a vector of indices. Negative estring values (in-\n * dels) are encoded as -1. Positive values are encoded as an increasing sequence\n * @example\n * const estring = [2, -3, 2];\n * estringToIdx(estring); // => [0, 1, -1, -1, -1, 2, 3]\n * @param {number[]} estring\n * @returns {number[]}\n */\nexport function estringToIdx (estring: number[]) {\n    const lIdx: number[] = [];\n    let idx = 0;\n    let val = 0;\n    for (let i = 0; i < estring.length; i ++) {\n        val = estring[i];\n        if (val < 0) {\n            for (let j = 0; j < -val; j ++) {\n                lIdx.push(-1);\n            }\n            continue;\n        }\n\n        for (let j = 0; j < val; j++) {\n            lIdx.push(idx);\n            idx++;\n        }\n    }\n    return lIdx;\n}","/**\n * @file align.ts\n * @author Paul Pillot <paul.pillot@libmol.org>\n * @license MIT\n * @copyright 2021\n * @description Routines for NW global alignment of biological sequences.\n * Most of this code is inspired by R.C. Edgar MUSCLE library (a).\n *\n * (a) Edgar, R.C. MUSCLE: a multiple sequence alignment method with reduced\n * time and space complexity. BMC Bioinformatics 5, 113 (2004).\n * https://doi.org/10.1186/1471-2105-5-113\n */\n\nimport { TAlignmentParam } from \"./params\";\nimport { TSequence } from \"../sequence/sequence\";\nimport { InternalNode, LeafNode } from \"../sequence/tree\";\nimport { epath2estring } from \"../utils/estring\";\n\n/**\n * Trace back matrix transitions values\n * Bits are used to create a bit mask that encodes every transition between the\n * 3 classical matrices\n * @enum {number}\n */\nconst enum TRACE_BACK {\n    MATCH     = 0,          // Match extension\n    DEL       = 1,          // Delete extension\n    INS       = 1 << 1,     // Insert extension\n    MATCH2DEL = 1 << 2,     // Delete opening\n    MATCH2INS = 1 << 3      // Insert opening\n};\n\nexport const enum ALIGNOPT {\n    DISABLE_FAVOR_START_GAP = 1,\n    DISABLE_FAVOR_END_GAP   = 1 << 1\n}\n\n\n/**\n * Pairwise sequence alignment\n *\n * @export\n * @param {TSequence} seqA\n * @param {TSequence} seqB\n * @param {number} [opt=0]\n * @returns\n */\nexport function pairwiseAlignment (\n    seqA: TSequence,\n    seqB: TSequence,\n    params: TAlignmentParam,\n    opt = 0\n) {\n\n    const sA = seqA.encodedSeq;\n    const sB = seqB.encodedSeq;\n    const lSeqALen = sA.length;\n    const lSeqBLen = sB.length;\n    let lMatch = 0,      // match score\n\n            // Textbook approach considers 3 n x m matrices for holding\n            // the match / delete / insert values computed. These could be\n            // reduced to only 2 vectors and 2 scalars\n\n        lMatchArr = [],     // Match column\n        lDelArr = [],       // Delete column\n        lPrevMatch = 0, // Scalar value containing match value computed at\n                        // the previous iteration in the same column (j-1).\n                        // Used as a rotation variable.\n        lLastInsert = 0,\n\n        tbIdx = 0,\n        isOdd = 0;\n\n    // Traceback matrix size: for convenience, an extra column has been added\n    // but will remain half empty (TODO: fix iteration boundaries).\n    // The traceback values are stored in a typed array of (n+1) * m / 2 bytes.\n    // Using bit values for M, I and D transitions, shifted depending on the matrix\n    // they encode, it's possible to encode all states using 4 bits.\n    // As a cell in the array contains 8 bits, each ultimately contains the\n    // results for 2 successive values in the DP matrix.\n\n    const tbM = new Uint8Array(Math.ceil((lSeqALen + 1) * lSeqBLen / 2)); // Trace back matrix\n\n\n    let gapOpenA = 0,\n        gapOpenB = 0,\n        gapExtentA = 0,\n        gapExtentB = 0,\n        tb = 0,         // trace back value. It's a bitmask of match + del + ins\n\n        matrix = params.scoringMatrix[0];    // memoization of the scoring matrix row for the\n                        // i-th amino acid.\n\n    // Fill in first columns in the matrix\n    // INITIALISATION\n    // half gap open penalty is a tweak to favor gaps at the opening\n    // (also at the end) of the sequence, the rational being that\n    // it is common to have ragged alignments between distant sequences.\n    // (This optimization comes from MAFFT and is applied in MUSCLE).\n    // Note that some applications may require on the contrary that the\n    // opening gap penalty is similar between internal and external gaps.\n    // e.g.: partial alignment between diagonals of a larger alignment.\n\n\n    const GAP_OPEN = params.gapOP;\n\n    const GAP_START_CORRECTION = opt & ALIGNOPT.DISABLE_FAVOR_START_GAP\n        ? 0\n        : - GAP_OPEN / 2;\n\n    const GAP_END_CORRECTION = opt & ALIGNOPT.DISABLE_FAVOR_END_GAP\n        ? 0\n        : - GAP_OPEN / 2;\n\n\n    lMatchArr[0] = 0;\n    lDelArr[0] = -Infinity;\n    for (let j = 1; j <= lSeqBLen; j++) {\n        lMatchArr[j] = GAP_OPEN + GAP_START_CORRECTION; // No gap extension penalty\n        lDelArr[j] = -Infinity;\n    }\n\n    // Main DP routine\n\n    for (let i = 1; i <= lSeqALen; i++) {\n\n        lPrevMatch = GAP_START_CORRECTION;\n        lLastInsert = -Infinity;\n        matrix = params.scoringMatrix[sA[i - 1]];   // memoize.\n\n        for (let j = 1; j <= lSeqBLen; j++) {\n            tb = TRACE_BACK.MATCH;\n\n\n            // Delete [i,j] score computation\n            //\n            //  lMatchArr was not cleared -> contains the computations\n            //      from the previous column (i-1).\n            //  lDelArr too.\n            //\n            //  - Gap extension is not computed due to the constant\n            //      added to the scoring matrix (see addCentre).\n\n\n            gapOpenA = lMatchArr[j] + GAP_OPEN;\n            gapExtentA = lDelArr[j];\n            if (j === lSeqBLen) {\n                gapOpenA += GAP_END_CORRECTION;\n            }\n\n            if (gapOpenA >= gapExtentA) {\n                lDelArr[j] = gapOpenA;\n            } else {\n                // No change on gap extent: lDelArr[j] += 0;\n                tb += TRACE_BACK.DEL;\n            }\n\n\n            // Insert [i,j] score computation\n            //  - lPrevMatch is the value that has just been computed\n            //      for the match at this column. We can't use lMatchArr\n            //      to store it yet, because for perf reason we are\n            //      saving space on this vector.\n            //  - ExtentB is still the score for the previous insert\n            //      value. Due to the addCentre() trick, no need to add\n            //      gap extension penalty here.\n\n            gapOpenB = lPrevMatch + GAP_OPEN;\n            gapExtentB = lLastInsert;\n\n            if (i === lSeqALen) {\n                gapOpenB += GAP_END_CORRECTION; // Terminal gap correction\n            }\n\n            if (gapOpenB >= gapExtentB) {\n                lLastInsert = gapOpenB;\n            } else {\n                // No score change on gap extend: lLastInsert += 0;\n                tb += TRACE_BACK.INS;\n            }\n\n\n            // Match [i,j] score computation\n            lMatch = lMatchArr[j - 1] + matrix[sB[j - 1]];\n\n            lMatchArr[j - 1] = lPrevMatch;  // var rotation\n\n            if (lMatch >= lLastInsert) {\n                if (lMatch >= lDelArr[j]) { // match is optimal\n                    lPrevMatch = lMatch;\n                } else {                    // delete is optimal\n                    lPrevMatch = lDelArr[j];\n                    tb += TRACE_BACK.MATCH2DEL;\n                }\n\n            } else {\n                if (lLastInsert >= lDelArr[j]) { // insert is optimal\n                    lPrevMatch = lLastInsert;\n                    tb += TRACE_BACK.MATCH2INS;\n                } else {                         // delete is optimal\n                    lPrevMatch = lDelArr[j];\n                    tb += TRACE_BACK.MATCH2DEL;\n                }\n            }\n\n            // Store trace-back bits\n            tbIdx = i * lSeqBLen + j;\n            isOdd =  tbIdx % 2;\n            tbIdx = tbIdx >>> 1;\n            if (isOdd) {\n                tbM[tbIdx] += tb;\n            } else {\n                tbM[tbIdx] += tb << 4;\n            }\n\n        }\n\n        // fix match vector for its last value\n        lMatchArr[lSeqBLen] = lPrevMatch;\n\n    }\n\n    // if (DEBUG) Log.add('End DP computation');\n\n    var score = Math.max(lMatch, lLastInsert, lDelArr[lDelArr.length - 1]);\n\n    // Traceback\n    const [lEpathA, lEpathB] = tracebBackToEpaths(tbM, lSeqALen, lSeqBLen, tb);\n\n    return {\n        estrings: [epath2estring(lEpathA), epath2estring(lEpathB)],\n        score\n    };\n};\n\n\n/**\n * Profile to sequence Alignment\n *\n * @param {LeafNode} nodeB a node object containing one sequence and its weight\n * @param {InternalNode} nodeA a node object containing a profile and its weight\n * @return {array) array containing aligned sequences\n */\nexport function MSASeqAlignment(\n    nodeA: InternalNode,\n    nodeB: LeafNode,\n    params: TAlignmentParam,\n    opt = 0\n) {\n\n    const seqB = nodeB.seq,\n        //wA = noeudA.weight, //probably unnecessary\n        lSeqBLen = seqB.rawSeq.length,\n        lProfALen = nodeA.profile.length;\n\n    let lMatch = 0.0,       // match score\n        lMatchArr: number[] = [],\n        lDelArr  : number[] = [];\n    const tbM = new Uint8Array(Math.ceil((lProfALen + 1) * (lSeqBLen + 1) / 2));\n    let tbIdx: number;\n    let isOdd: number;\n\n    let lGapOpenA = 0.0,\n        lGapOpenB = 0.0,\n        lGapExtendA = 0.0,\n        lGapExtendB = 0.0,\n        tb = 0,\n        lLastInsert = 0.0,\n        lPrevLastInsert = 0.0,\n        lPrevMatch = 0.0,\n        lDeletej_1 = 0.0,\n        lInserti_1 = 0.0,\n        /** Position specific gap open penaly of profile A at pos i-1 */\n        lProfAGapOP = 0.0,\n        /** Position specific gap close penalty of profile A at pos i-1 */\n        lProfAGapCP = 0.0,\n        /** Position specific substitution scores of profile A at pos i-1 */\n        lProfASScores = new Float32Array(params.abSize);\n\n    const GAP_OPEN    = params.gapOP;\n    const GAP_OPEN_B  = GAP_OPEN / 2;\n    const GAP_CLOSE_B = GAP_OPEN / 2;\n\n    const GAP_START_CORRECTION_B = opt & ALIGNOPT.DISABLE_FAVOR_START_GAP\n        ? 0\n        : - GAP_OPEN / 4;\n\n    const GAP_END_CORRECTION_B = opt & ALIGNOPT.DISABLE_FAVOR_END_GAP\n        ? 0\n        : - GAP_OPEN / 4;\n\n    // sequence B as a vector of integers\n    const sB = seqB.encodedSeq;\n\n    // Convert MSA in node B to profile\n    const profA = nodeA.profile;\n\n    // Note that for performance reason, the outer loop iterates on profile A.\n    // This allows caching the values for substitution scores used in the inner\n    // loop when iterating over seqB values.\n\n    // INITIALIZATION of DP vectors\n    lMatchArr[0] = 0;\n    lDelArr[0] = -Infinity;\n    for (let j = 1; j <= lSeqBLen; j++) {\n        lMatchArr[j] = GAP_OPEN_B + GAP_CLOSE_B + GAP_START_CORRECTION_B; //gap open at j=0 + gap close at j-1\n        lDelArr[j] = -Infinity;\n    }\n\n    //Main DP routine\n    // Note that profile's gap penalties are halved at their extremities\n\n    for (let i = 1; i <= lProfALen; i++) {\n\n        lProfAGapOP = profA.m_ScoreGapOpen[i - 1];\n        lProfAGapCP = profA.m_ScoreGapClose[i - 1];\n        lProfASScores = profA.m_AAScores.subarray((i - 1) * params.abSize, i * params.abSize);\n\n            // lPrevMatch is a scalar, used to compute on the same column (iterations\n            // over j) the gap open penalty\n        lPrevMatch = GAP_START_CORRECTION_B;\n        lLastInsert = -Infinity;\n        lDelArr[0] = profA.m_ScoreGapOpen[0];\n\n        for (let j = 1; j <= lSeqBLen; j++) {\n            tb = TRACE_BACK.MATCH;\n\n            //Delete i,j score computation\n            lGapOpenA = lMatchArr[j] + lProfAGapOP; //\n            lGapExtendA = lDelArr[j];\n            if (j === lSeqBLen) { //terminal penalties are halved\n                lGapOpenA -= lProfAGapOP / 2;\n            }\n\n            if (lGapOpenA >= lGapExtendA) {\n                lDelArr[j] = lGapOpenA;\n            } else {\n                //Delete[j] = gapExtendA;\n                tb += TRACE_BACK.DEL;\n            }\n\n            //Insert i,j score computation\n            lGapOpenB = lPrevMatch + GAP_OPEN_B;\n            lGapExtendB = lPrevLastInsert = lLastInsert;\n            if (i === lProfALen) {\n                lGapOpenB += GAP_END_CORRECTION_B;\n            }\n\n            if (lGapOpenB >= lGapExtendB) {\n                lLastInsert = lGapOpenB;\n            } else {\n                //gap extend, not score change;\n                tb += TRACE_BACK.INS;\n            }\n\n            //Match i,j score computation\n            lDeletej_1 = lDelArr[j] + lProfAGapCP; //it should be prev\n            lInserti_1 = lPrevLastInsert + GAP_CLOSE_B;\n            lMatch = lMatchArr[j - 1] + lProfASScores[sB[j - 1]];\n\n            if (j === lSeqBLen) {\n                lInserti_1 += GAP_END_CORRECTION_B;\n            }\n\n            lMatchArr[j - 1] = lPrevMatch;\n\n            if (lMatch >= lInserti_1) {\n                if (lMatch >= lDeletej_1) { //match is optimal\n                    lPrevMatch = lMatch;\n                } else { //delete is optimal\n                    lPrevMatch = lDeletej_1;\n                    tb += TRACE_BACK.MATCH2DEL;\n                }\n\n            } else {\n                if (lInserti_1 >= lDeletej_1) { //insert is optimal\n                    lPrevMatch = lInserti_1;\n                    tb += TRACE_BACK.MATCH2INS;\n                } else { //delete is optimal\n                    lPrevMatch = lDeletej_1;\n                    tb += TRACE_BACK.MATCH2DEL;\n                }\n            }\n\n            // Store trace-back bits\n            tbIdx = i * lSeqBLen + j;\n            isOdd =  tbIdx % 2;\n            tbIdx = tbIdx >>> 1;\n            if (isOdd) {\n                tbM[tbIdx] += tb;\n            } else {\n                tbM[tbIdx] += tb << 4;\n            }\n        }\n        lMatchArr[lSeqBLen] = lPrevMatch;\n    }\n    const score = Math.max(lMatch, lLastInsert, lDelArr[lDelArr.length - 2]);\n\n    //traceback\n    const [lEpathA, lEpathB] = tracebBackToEpaths(tbM, lProfALen, lSeqBLen, tb);\n\n    return {\n        estrings: [epath2estring(lEpathA), epath2estring(lEpathB)],\n        score\n    };\n}\n\n/**\n * profile to profile alignment\n * @param {object} nodeA a node object containing a multiple sequence alignment and its weight\n * @param {object} nodeB a node object containing a multiple sequence alignment and its weight\n */\n\nexport function MSAMSAAlignment(\n    nodeA: InternalNode,\n    nodeB: InternalNode,\n    params: TAlignmentParam,\n    opt = 0\n) {\n\n    const lProfALen = nodeA.profile.length,\n        lProfBLen = nodeB.profile.length,\n        tbM = new Uint8Array(Math.ceil((lProfALen + 1) * (lProfBLen + 1) / 2));\n    let tbIdx: number;\n    let isOdd: number;\n\n    let lMatchArr: number[] = [],\n        lDelArr: number[] = [],\n        lMatch      = 0.0,\n        lGapOpenA   = 0.0,\n        lGapOpenB   = 0.0,\n        lGapExtendA = 0.0,\n        lGapExtendB = 0.0,\n        tb = 0|0,\n        lLastInsert = 0.0,\n        lPrevLastInsert = 0,\n        lPrevMatch  = 0.0,\n        lDeletej_1  = 0.0,\n        lInserti_1  = 0.0,\n        lProfAGapOP = 0.0,\n        lProfAGapCP = 0.0,\n        lProfAAAScores = new Float32Array(params.abSize),\n        lResList = new Uint8Array(params.abSize),\n        lResProfNb = 0,\n        lOffset = 0,\n        kmax = 0,\n        i = 0,\n        j = 0,\n        k = 0;\n\n    const GAP_START_FACTOR = opt & ALIGNOPT.DISABLE_FAVOR_START_GAP ? 1 : 2;\n\n    //convert to profile\n    const profB = nodeB.profile;\n    const profA = nodeA.profile;\n\n\n\n    //INITIALIZATION of DP vectors\n    lMatchArr[0] = 0;\n    lDelArr[0] = -Infinity;\n    for (j = 1; j <= lProfBLen; j++) {\n        lMatchArr[j] = profB.m_ScoreGapOpen[0] + profB.m_ScoreGapClose[j - 1] / GAP_START_FACTOR;\n        lDelArr[j] = -Infinity;\n    }\n\n    const M0 = profA.m_ScoreGapOpen[0];\n\n    //Main DP routine\n\n    for (i = 1; i <= lProfALen; i++) {\n        lProfAAAScores = profA.m_AAScores.subarray(params.abSize * (i - 1), params.abSize * i);\n        lProfAGapOP = profA.m_ScoreGapOpen[i - 1];\n        lProfAGapCP = profA.m_ScoreGapClose[i - 1];\n\n        //M0 += profAGapEP / 2;\n\n        lPrevMatch = M0 + lProfAGapCP / GAP_START_FACTOR;\n        lLastInsert = -Infinity;\n        lDelArr[0] = profA.m_ScoreGapOpen[0];\n\n        for (j = 1; j <= lProfBLen; j++) {\n            tb = TRACE_BACK.MATCH;\n\n            //Delete i,j score computation\n            lGapOpenA = lMatchArr[j] + lProfAGapOP; //\n            lGapExtendA = lDelArr[j];\n            if (j === lProfBLen && !(opt & ALIGNOPT.DISABLE_FAVOR_END_GAP)) {\n                lGapOpenA -= lProfAGapOP / 2;\n            }\n\n            if (lGapOpenA >= lGapExtendA) {\n                lDelArr[j] = lGapOpenA;\n            } else {\n                //Delete[j] = gapExtendA;\n                tb += TRACE_BACK.DEL;\n            }\n\n            //Insert i,j score computation\n            lGapOpenB = lPrevMatch + profB.m_ScoreGapOpen[j - 1];\n            lGapExtendB = lPrevLastInsert = lLastInsert;\n            if (i === lProfALen && !(opt & ALIGNOPT.DISABLE_FAVOR_END_GAP)) {\n                lGapOpenB -= profB.m_ScoreGapOpen[j - 1] / 2;\n            }\n\n            if (lGapOpenB >= lGapExtendB) {\n                lLastInsert = lGapOpenB;\n            } else {\n                //lastInsert = gapExtendB;\n                tb += TRACE_BACK.INS;\n            }\n\n            //Match i,j score computation\n            // Note: could be a separate function, but runs faster when inlined\n            lMatch = lMatchArr[j - 1];\n            kmax = profB.m_uResidueGroup[j - 1];\n            k = 0;\n            lOffset = (j - 1) * params.abSize;\n            lResList = profB.m_uSortOrder.subarray(lOffset, lOffset + kmax );\n            while (k < kmax) {\n                lResProfNb = lResList[k];\n                lMatch += profB.m_wCounts[lOffset + lResProfNb] * lProfAAAScores[lResProfNb];\n                k++;\n            }\n\n            //match = Match[j - 1] + _utils.sumOfPairsScorePP3(profAAAScores, profB[j - 1]);\n            lDeletej_1 = lDelArr[j] + lProfAGapCP;\n            lInserti_1 = lPrevLastInsert + profB.m_ScoreGapClose[j - 1];\n\n            if (j === 1 && !(opt & ALIGNOPT.DISABLE_FAVOR_END_GAP)) { //terminal penalties are halved\n                lDeletej_1 -= lProfAGapCP / 2;\n            }\n            if ((j === lProfBLen) && !(opt & ALIGNOPT.DISABLE_FAVOR_END_GAP)) {\n                lDeletej_1 -= lProfAGapCP / 2;\n                lInserti_1 -= profB.m_ScoreGapClose[lProfBLen - 1] / 2;\n            }\n\n            lMatchArr[j - 1] = lPrevMatch;\n\n            if (lMatch >= lInserti_1) {\n                if (lMatch >= lDeletej_1) { //match is optimal\n                    lPrevMatch = lMatch;\n                } else { //delete is optimal\n                    lPrevMatch = lDeletej_1;\n                    tb += TRACE_BACK.MATCH2DEL;\n                }\n\n            } else {\n                if (lInserti_1 >= lDeletej_1) { //insert is optimal\n                    lPrevMatch = lInserti_1;\n                    tb += TRACE_BACK.MATCH2INS;\n                } else { //delete is optimal\n                    lPrevMatch = lDeletej_1;\n                    tb += TRACE_BACK.MATCH2DEL;\n                }\n            }\n\n            // Store trace-back bits\n            tbIdx = i * lProfBLen + j;\n            isOdd =  tbIdx % 2;\n            tbIdx = tbIdx >>> 1;\n            if (isOdd) {\n                tbM[tbIdx] += tb;\n            } else {\n                tbM[tbIdx] += tb << 4;\n            }\n\n        }\n        lMatchArr[lProfBLen] = lPrevMatch;\n    }\n    const score = Math.max(lMatch, lLastInsert, lDelArr[j - 1]);\n\n    //traceback\n    const [lEpathA, lEpathB] = tracebBackToEpaths(tbM, lProfALen, lProfBLen, tb);\n\n    return {\n        estrings: [epath2estring(lEpathA), epath2estring(lEpathB)],\n        score\n    };\n}\n\n/**\n * Converts a traceback matrix to two edit paths, that is two arrays containing\n * either 1 (add one letter from sequence) or -1 (add one gap in the alignment)\n *\n * @param {Uint8Array} tbM traceback matrix as computed by the DP\n * @param {number} lenA length of sequence/profile A\n * @param {number} lenB length of sequence/profile B\n * @param {number} tb0  for convenience, first value to use for starting\n * @returns\n */\nfunction tracebBackToEpaths (tbM: Uint8Array, lenA: number, lenB: number, tb0: number) {\n\n    // Move backwards starting from the last optimal scoring position\n    // in the TB matrix.\n\n    let i = lenA;\n    let j = lenB;\n    let lIdx = lenA * lenB + lenB;\n    let tbIdx = lIdx;\n    let isOdd = 1;  // will be overwritten\n    const lEpathA: number[] = [];\n    const lEpathB: number[] = [];\n\n    // current matrix is either M (0), D (1) or I(2). Let's have a look\n    // at the last value to see if the optimum is coming from DEL\n    // (bit value 4) or INS (bit value 8) or Match (no bit value)\n\n    let lCurrentMatrix = (tb0 & 12) >> 2,   // 0: Match, 1: Delete, 2: Insert\n        val = 0;\n    while ((i > 0) && (j > 0)) {\n        lIdx = i * lenB + j;    // idx in original traceback matrix\n        tbIdx = lIdx >>> 1;     // idx in compressed tb mtx\n        isOdd = lIdx % 2;\n        val = tbM[tbIdx];\n        val = isOdd ? val & 0b1111 : val >>> 4; // either 4 least/most significant bits\n\n        if (lCurrentMatrix === 0) {\n            val = val >> 2;     // Can come from M, D or I\n            if (val === 0) {    // Match\n                i--;\n                j--;\n                lEpathA.push(1);\n                lEpathB.push(1);\n            }\n            // other cases --> run the loop once more to enter the\n            // following block.\n        } else {\n            if (lCurrentMatrix === 2) { // Insert\n                lEpathA.push(-1);\n                lEpathB.push(1);\n                val = val & 2;          // Comes from I or M\n                j--;\n            } else {                    // 1 Delete\n                lEpathA.push(1);\n                lEpathB.push(-1);\n                val = val & 1;          // Comes from D or M\n                i--;\n            }\n        }\n        lCurrentMatrix = val;\n    }\n\n    // Finish sequences edit by appending the remaining symbols\n    if (i > 0) {\n        lEpathA.push(i);\n        lEpathB.push(-i);\n    } else if (j > 0) {\n        lEpathA.push(-j);\n        lEpathB.push(j);\n    }\n\n    return [lEpathA, lEpathB];\n}\n","/**\n * @file profile\n * @author Paul Pillot <paul.pillot@libmol.org>\n * @license MIT\n * @copyright 2020\n */\n\nimport { ALIGNOPT } from '../align/align';\nimport { SEQUENCE_TYPE, TAlignmentParam } from '../align/params';\nimport BitArray from '../utils/bitarray';\nimport { estringLength, estringToIdx } from '../utils/estring';\nimport { aaToNum, nucToNum, TSequence } from './sequence';\n\n\n/*\n * ProfPos definition ()\n */\nexport class ProfPos {\n    m_bAllGaps: BitArray;\n    /** Residues present at this position unordered */\n    m_uSortOrder: Uint8Array;\n\n    /** Residues counts */\n    m_fcCounts: Uint8Array;\n\n    /** Weighted contribution per residue */\n    m_wCounts: Float32Array;\n    // m_LL = 1;\n    // m_LG = 0;\n    // m_GL = 0;\n    // m_GG = 0;\n\n    /** Substitution score computed at this position */\n    m_AAScores: Float32Array;\n\n    /** Residue diversity (count per residue) */\n    m_uResidueGroup: Uint8Array;\n\n    /** Occupancy (non-indels) */\n    m_fOcc: Float32Array;\n\n    /** Frequency of opening gaps */\n    m_fcStartOcc: Float32Array;\n\n    /** Frequency of closing gaps */\n    m_fcEndOcc: Float32Array;\n\n    /** Gap Open penalty computed for this position */\n    m_ScoreGapOpen: Float32Array;\n\n    /** Gap Close penalty computed for this position */\n    m_ScoreGapClose: Float32Array;\n\n    /** Sequence count in this profile */\n    nbSeq = 0;\n    alphaSize: number;\n    length = 0;\n    weight = 0;\n\n    constructor (pSize: number, pAlphaSize: number, pNbSeq: number, pWeight = 0) {\n        this.length = pSize;\n        this.m_bAllGaps = new BitArray(pSize);\n        this.m_uSortOrder = new Uint8Array(pAlphaSize * pSize);\n        this.m_fcCounts = new Uint8Array(pAlphaSize * pSize);\n        this.m_wCounts = new Float32Array(pAlphaSize * pSize);\n        this.m_AAScores = new Float32Array(pAlphaSize * pSize);\n        this.m_uResidueGroup = new Uint8Array(pSize);\n        this.m_fOcc = new Float32Array(pSize);\n        this.m_fcStartOcc = new Float32Array(pSize);\n        this.m_fcEndOcc = new Float32Array(pSize);\n        this.m_ScoreGapOpen = new Float32Array(pSize);\n        this.m_ScoreGapClose = new Float32Array(pSize);\n        this.nbSeq = pNbSeq;\n        this.alphaSize = pAlphaSize;\n        this.weight = pWeight;\n    }\n\n    getProxy (id = 0) {\n        return new ProfProxy(this, id);\n    }\n}\n\nclass ProfProxy {\n\n    prof: ProfPos;\n    idx: number = 0;\n    alphaSize = 4;\n    offset = 0;\n\n    constructor(pProf: ProfPos, pIdx = 0) {\n        this.prof = pProf;\n        this.idx = pIdx;\n        this.alphaSize = pProf.alphaSize;\n        this.offset = this.idx * this.alphaSize;\n    }\n\n    setProxy (pIdx: number) {\n        this.idx = pIdx;\n        this.offset = pIdx * this.alphaSize;\n    }\n\n    get m_bAllGaps () {\n        return this.prof.m_bAllGaps.get(this.idx);\n    }\n    set m_bAllGaps (val: boolean) {\n        if (val) this.prof.m_bAllGaps.set(this.idx)\n        else this.prof.m_bAllGaps.clear(this.idx);\n    }\n\n    get m_uSortOrder () {\n        return this.prof.m_uSortOrder.subarray(this.offset, this.offset + this.alphaSize);\n    }\n    set m_uSortOrder (val: Uint8Array) {\n        this.prof.m_uSortOrder.set(val, this.offset);\n    }\n\n    get m_uResidueGroup () {\n        return this.prof.m_uResidueGroup[this.idx];\n    }\n    set m_uResidueGroup (val: number) {\n        this.prof.m_uResidueGroup[this.idx] = val;\n    }\n\n\n    get m_fcCounts () {\n        return this.prof.m_fcCounts.subarray(this.offset, this.offset + this.alphaSize);\n    }\n    set m_fcCounts (val: Uint8Array) {\n        this.prof.m_fcCounts.set(val, this.offset);\n    }\n\n\n    get m_wCounts () {\n        return this.prof.m_wCounts.subarray(this.offset, this.offset + this.alphaSize);\n    }\n    set m_wCounts (val: Float32Array) {\n        this.prof.m_wCounts.set(val, this.offset);\n    }\n\n    get m_AAScores () {\n        return this.prof.m_AAScores.subarray(this.offset, this.offset + this.alphaSize);\n    }\n    set m_AAScores (val: Float32Array) {\n        this.prof.m_AAScores.set(val, this.offset);\n    }\n\n    get m_fOcc () {\n        return this.prof.m_fOcc[this.idx];\n    }\n    set m_fOcc (val: number) {\n        this.prof.m_fOcc[this.idx] = val;\n    }\n\n    get m_fcStartOcc () {\n        return this.prof.m_fcStartOcc[this.idx];\n    }\n    set m_fcStartOcc (val: number) {\n        this.prof.m_fcStartOcc[this.idx] = val;\n    }\n\n    get m_fcEndOcc () {\n        return this.prof.m_fcEndOcc[this.idx];\n    }\n    set m_fcEndOcc (val: number) {\n        this.prof.m_fcEndOcc[this.idx] = val;\n    }\n\n    get m_ScoreGapOpen () {\n        return this.prof.m_ScoreGapOpen[this.idx];\n    }\n    set m_ScoreGapOpen (val: number) {\n        this.prof.m_ScoreGapOpen[this.idx] = val;\n    }\n\n    get m_ScoreGapClose () {\n        return this.prof.m_ScoreGapClose[this.idx];\n    }\n    set m_ScoreGapClose (val: number) {\n        this.prof.m_ScoreGapClose[this.idx] = val;\n    }\n}\n\n/**\n * Compute Profile from MSA\n * A profile stores at each column of the alignment a statistical representation\n * of the alignment properties suitable for computing alignment scores against\n * a sequence or another profile.\n * The data structure modeling the profile is a store containing numerical\n * values for the different properties (residue counts, etc...)\n * @param {string[]} pMSA: aligned sequences as an array of strings with `-` as\n *                          indels.\n * @param {number}  pGapO: gap opening penalty\n * @param {number[]} pWeights : weight of each sequence\n */\nexport function profileFromMSA (pMSA: string[], pWeights: number[], params: TAlignmentParam,\n    opt: number = 0) {\n    /** alignment length (columns count) */\n    const l = pMSA[0].length;\n\n    let aa = '', // amino acid name (1 letter code)\n        na = 0,  // amino acid # (in lexical order)\n        tabCodeResNum: Uint8Array;\n    if (params.type === SEQUENCE_TYPE.NUCLEIC) {\n        tabCodeResNum = nucToNum;\n    } else {\n        tabCodeResNum = aaToNum;\n    }\n\n    //uHydrophobicRunLength = 0, // hydrophobic window (to avoid introducing gaps within)\n    let w = 0, //sequence weight\n        totalW = pWeights.reduce((a, b) =>  a + b, 0);\n\n    const lProf = new ProfPos(l, params.abSize, pMSA.length, totalW);\n\n    const lGapO = params.gapOP;\n    let lProx = lProf.getProxy();\n\n    for (let col = 0; col < l; col++) {\n        lProx.setProxy(col);\n        let fGap = 0;\n\n        for (let numSeq = 0, max = pMSA.length; numSeq < max; numSeq++) {\n\n            w = pWeights[numSeq];\n            aa = pMSA[numSeq][col];\n            if (aa === '-') {\n                fGap += w;\n\n                if (col === 0 || pMSA[numSeq][col - 1] !== '-') {\n                    lProx.m_fcStartOcc += w;\n                }\n\n                if (col === l - 1 || pMSA[numSeq][col + 1] !== '-') {\n                    lProx.m_fcEndOcc += w;\n                }\n\n            } else {\n                na = tabCodeResNum[aa.charCodeAt(0)];\n                lProx.m_fcCounts[na]++;\n                lProx.m_wCounts[na] += w;\n                if (lProx.m_fcCounts[na] === 1) {\n                    lProx.m_uSortOrder[lProx.m_uResidueGroup] = na;\n                    lProx.m_uResidueGroup++;\n                }\n            }\n        }\n        lProx.m_fOcc = totalW - fGap;\n        lProx.m_ScoreGapOpen = lGapO / 2 * (1 - lProx.m_fcStartOcc);\n        lProx.m_ScoreGapClose = lGapO / 2 * (1 - lProx.m_fcEndOcc);\n\n            // Cache substitution scores at this position\n\n        let imax = lProx.m_uResidueGroup;\n        let lSortOrder = lProx.m_uSortOrder;\n        let lScore = 0, lResProfNb = 0;\n        for (let aaNum = 0; aaNum < params.abSize; aaNum++) {\n            lScore = 0;\n            for (let i = 0; i < imax; i++) {\n                lResProfNb = lSortOrder[i];\n                lScore += lProx.m_wCounts[lResProfNb] * params.scoringMatrix[aaNum][lResProfNb];\n            }\n            lProx.m_AAScores[aaNum] = lScore;\n        }\n    }\n\n\n    //  Corrections for end/begin gap penalties\n    if (opt ^ ALIGNOPT.DISABLE_FAVOR_START_GAP) {\n        lProf.m_ScoreGapOpen[0]  /= 2;\n        lProf.m_ScoreGapOpen[l-1]  /= 2;\n    }\n    if (opt ^ ALIGNOPT.DISABLE_FAVOR_END_GAP) {\n        lProf.m_ScoreGapClose[0] /= 2;\n        lProf.m_ScoreGapClose[l-1] /= 2;\n    }\n\n\n    return lProf;\n}\n\n/**\n * Utility function to make a profile object from a single sequence\n * @param {TSequence} pSeq: Sequence object\n * @param {number} pWeight: Sequence weight\n * @param {TAlignmentParam} pParams: Alignment parameters. Defines penalties.\n * @param {number} opt: option as a bitmask\n */\nexport function seqToProf (pSeq: TSequence, pWeight: number, params: TAlignmentParam, opt = 0) {\n    const lEncSeq = pSeq.encodedSeq;\n    /** alignment length (columns count) */\n    const l = lEncSeq.length;\n\n    const lProf = new ProfPos(l, params.abSize, 1, pWeight);\n\n    let w = pWeight; //sequence weight\n\n\n    const lGapO = params.gapOP;\n    let lProx = lProf.getProxy();\n    let lResNb = 0;\n\n    for (let col = 0; col < l; col++) {\n        lProx.setProxy(col);\n\n        lResNb = lEncSeq[col];\n        lProx.m_fcCounts[lResNb]= 1;\n        lProx.m_wCounts[lResNb] = w;\n        lProx.m_uSortOrder[lProx.m_uResidueGroup] = lResNb;\n        lProx.m_uResidueGroup = 1;\n        lProx.m_fOcc = w;\n        lProx.m_ScoreGapOpen  = lGapO / 2 * w;\n        lProx.m_ScoreGapClose = lGapO / 2 * w;\n\n            // Cache substitution scores at this position\n\n        for (let aaNum = 0; aaNum < params.abSize; aaNum++) {\n            lProx.m_AAScores[aaNum] = w * params.scoringMatrix[aaNum][lResNb];\n        }\n    }\n\n\n    //  Corrections for end/begin gap penalties\n    if (!(opt & ALIGNOPT.DISABLE_FAVOR_START_GAP)) {\n        lProf.m_ScoreGapOpen[0]  /= 2;\n        lProf.m_ScoreGapOpen[l-1]  /= 2;\n    }\n    if (!(opt & ALIGNOPT.DISABLE_FAVOR_END_GAP)) {\n        lProf.m_ScoreGapClose[0] /= 2;\n        lProf.m_ScoreGapClose[l-1] /= 2;\n    }\n\n\n    return lProf;\n}\n\n/**\n * Compute a profile from two profiles and two edit strings\n *\n * @export\n * @param {ProfPos} pProfA\n * @param {ProfPos} pProfB\n * @param {number[]} pESA\n * @param {number[]} pESB\n * @param {TAlignmentParam} params\n * @param {number} [opt=0]\n * @returns\n */\nexport function mergeProfiles (pProfA: ProfPos, pProfB: ProfPos, pESA: number[], pESB: number[], params: TAlignmentParam, opt: number = 0) {\n\n    /** profile length (alignment length, columns count) */\n    const l = estringLength(pESA);\n    const n = pProfA.nbSeq + pProfB.nbSeq;\n    const w = pProfA.weight + pProfB.weight;\n\n    const lProf = new ProfPos(l, params.abSize, n, w);\n\n    console.log(pProfA.weight, pProfB.weight, w)\n\n    const lGapO = params.gapOP;\n    let lProx = lProf.getProxy();\n    let lProxA = pProfA.getProxy();\n    let lProxB = pProfB.getProxy();\n\n    // indices to map columns in the new profile to the columns in the original\n    // profiles.\n    let lAidx = estringToIdx(pESA);\n    let lBidx = estringToIdx(pESB);\n    let lAi = 0;\n    let lBi = 0;\n\n    let lAiPrev = 1;    // used to detect gap opening/closing\n    let lBiPrev = 1;\n    let lAisGapOpening = false;\n    let lAisGapClosing = false;\n    let lBisGapOpening = false;\n    let lBisGapClosing = false;\n\n    let lNbRes = 0;     // nb of distinct residues at this column\n\n\n    for (let col = 0; col < l; col++) {\n        lProx.setProxy(col);\n\n        lAi = lAidx[col];\n        lProxA.setProxy(lAi);\n        if (lAi === -1) {\n            lAisGapOpening = lAiPrev >= 0;\n            lAisGapClosing = col === l - 1  // end of profile\n                || lAidx[col + 1] > 0;      // next is not part of this indel\n        } else {\n            lAisGapOpening = false;\n            lAisGapClosing = false;\n        }\n        lAiPrev = lAi;\n\n        lBi = lBidx[col];\n        lProxB.setProxy(lBi);\n        if (lBi === -1) {\n            lBisGapOpening = lBiPrev >= 0;\n            lBisGapClosing = col == l - 1\n                || lBidx[col + 1] > 0;\n        } else {\n            lBisGapOpening = false;\n            lBisGapClosing = false;\n        }\n        lBiPrev = lBi;\n\n        lNbRes = 0;\n\n            // First case: no gap introduced at this position\n\n        if (lAi !== -1 && lBi !== -1) {\n            lProx.m_fcStartOcc = lProxA.m_fcStartOcc + lProxB.m_fcStartOcc;\n            lProx.m_fcEndOcc   = lProxA.m_fcEndOcc   + lProxB.m_fcEndOcc;\n            lProx.m_fOcc       = lProxA.m_fOcc       + lProxB.m_fOcc;\n            lProx.m_fcCounts.set(lProxA.m_fcCounts);\n            lProx.m_wCounts .set(lProxA.m_wCounts);\n            for (let i = 0; i < pProfB.alphaSize; i++) {\n                let v = pProfB.m_fcCounts[i];\n                if (v) {\n                    lProx.m_fcCounts[i] += v;\n                    lProx.m_wCounts[i] += pProfB.m_wCounts[i];\n                }\n                if (lProx.m_fcCounts[i]) {\n                    lProx.m_uSortOrder[lNbRes] = i;\n                    lNbRes ++;\n                }\n                lProx.m_AAScores[i] = lProxA.m_AAScores[i] + lProxB.m_AAScores[i];\n            }\n            lProx.m_uResidueGroup = lNbRes;\n        }\n\n            // Gap introduced in profile A only\n\n        else if (lAi == -1) {\n            lProx.m_fcStartOcc = lProxB.m_fcStartOcc + (lAisGapOpening ? pProfA.weight : 0);\n            lProx.m_fcEndOcc   = lProxB.m_fcEndOcc   + (lAisGapClosing ? pProfA.weight : 0);\n            lProx.m_fOcc       = lProxB.m_fOcc;\n            lProx.m_fcCounts.set(lProxB.m_fcCounts);\n            lProx.m_wCounts.set(lProxB.m_wCounts);\n            lProx.m_uSortOrder.set(lProxB.m_uSortOrder);\n            lProx.m_AAScores.set(lProxB.m_AAScores);\n            lProx.m_uResidueGroup = lProxB.m_uResidueGroup;\n        }\n\n            // Gap introduced in profile B only\n\n        else if (lBi == -1) {\n            lProx.m_fcStartOcc = lProxA.m_fcStartOcc + (lBisGapOpening ? pProfB.weight : 0);\n            lProx.m_fcEndOcc   = lProxA.m_fcEndOcc   + (lBisGapClosing ? pProfB.weight : 0);\n            lProx.m_fOcc       = lProxA.m_fOcc;\n            lProx.m_fcCounts.set(lProxA.m_fcCounts);\n            lProx.m_wCounts.set(lProxA.m_wCounts);\n            lProx.m_uSortOrder.set(lProxA.m_uSortOrder);\n            lProx.m_AAScores.set(lProxA.m_AAScores);\n            lProx.m_uResidueGroup = lProxA.m_uResidueGroup;\n        }\n\n            // Open gap penalty is half the global gap open penalty,\n            // weighted, reduced by the number of gaps already there\n            // and opened at the same position.\n\n        lProx.m_ScoreGapOpen  = lGapO / 2 * (1 - lProx.m_fcStartOcc) * lProx.m_fOcc;\n        lProx.m_ScoreGapClose = lGapO / 2 * (1 - lProx.m_fcEndOcc)   * lProx.m_fOcc;\n\n    }\n\n    //  Corrections to end/begin gap penalties\n    if (!(opt & ALIGNOPT.DISABLE_FAVOR_START_GAP)) {\n        lProf.m_ScoreGapOpen[0]  /= 2;\n        lProf.m_ScoreGapOpen[l-1]  /= 2;\n    }\n    if (!(opt & ALIGNOPT.DISABLE_FAVOR_END_GAP)) {\n        lProf.m_ScoreGapClose[0] /= 2;\n        lProf.m_ScoreGapClose[l-1] /= 2;\n    }\n\n\n    return lProf;\n}","/**\n * @file tree\n * @author Paul Pillot <paul.pillot@libmol.org>\n * @license MIT\n * @copyright 2020\n */\n\nimport { TAlignmentParam } from '../align/params';\nimport { seqToProf, ProfPos } from './profile';\nimport { TSequence } from './sequence';\n\nexport enum NODE_TYPE {\n    LEAF,\n    NODE,\n    ROOT\n}\n\nexport type LeafNode = {\n    seq: TSequence;\n    profile: ProfPos;\n    childA: number;\n    childB: number;\n    distance: number;\n    numSeq: number[];\n    msa: string[];\n    id: string,\n    weight: number,\n    parent: number,\n    depth: number,\n    type: NODE_TYPE\n};\n\nexport type InternalNode = Omit<LeafNode, 'seq'> & {\n    estring: number[][],\n    profile: ProfPos,\n    tabWeight: number[]\n};\n\nexport function isLeafNode(node: LeafNode | InternalNode): node is LeafNode {\n    return 'seq' in node;\n}\n\nexport type Tree = (LeafNode|InternalNode)[];\n\n/**\n * Cluster sequences based on a distance Matrix using the UPGMA algorithm\n *\n * @export\n * @param {*} mD\n * @param {*} tSeq\n * @returns\n */\nexport function makeTree(mD: number[][], tSeq: TSequence[]) {\n    let clusters: Tree = [];\n    let nbSeq = mD.length;\n    let tabIdx: number[] = [];\n\n    for (var i = 0; i < nbSeq; i++) {\n        clusters[i] = {\n            type: NODE_TYPE.LEAF,\n            seq: tSeq[i],\n            profile: null as unknown as ProfPos,\n            childA: i,\n            childB: i,\n            distance: 0,\n            numSeq: [i],\n            msa: [],\n            id: i.toString(),\n            weight: 0,\n            parent: -1,\n            depth: 0\n        };\n        tabIdx[i] = i;\n    }\n\n    let lNode: InternalNode;\n    let lMinX: number;  // index in matrix of column with the min value\n    let lMinY: number;  // index in matrix of row with the min value.\n    for (var i = 0, nbIterations = nbSeq - 1; i < nbIterations; i++) {\n        // Make a node from the min value in distance matrix\n\n        [lNode, lMinX, lMinY] = findMinInDistanceMatrix(mD, tabIdx);\n\n        // Finalize node data with child properties\n        const lChildA = clusters[lNode.childA];\n        const lChildB = clusters[lNode.childB];\n\n        // The id is canonical as long as the same lexical sorting is applied.\n        // This will be used later on to compare trees topologies.\n        lNode.id = (lChildA.id < lChildB.id) ?\n              `|${ lChildA.id },${ lChildB.id }|`\n            : `|${ lChildB.id },${ lChildA.id }|`;\n\n        lNode.depth = Math.max(lChildA.depth, lChildB.depth) + 1;\n\n        lChildB.parent = lChildA.parent = clusters.length;\n\n        // Add references to find back node\n\n        tabIdx.push(nbSeq + i);\n        clusters.push(lNode);\n\n        // Recompute matrix\n\n        mD = recomputeDistMatrix(mD, lMinX, lMinY, tabIdx);\n    }\n\n    clusters[clusters.length - 1].type = NODE_TYPE.ROOT;\n\n    return clusters;\n}\n\n/**\n * Loop through the distance matrix to find the minimum\n * TODO: this is O(n^2) and can easily be made O(n) by maintaining a vector\n * of minimum values and their position in each row of the matrix.\n * @param matrix\n * @param tabIdx\n */\nfunction findMinInDistanceMatrix (\n    matrix: number[][],\n    tabIdx: number[]\n): [InternalNode, number, number] {\n    let min = Infinity,\n        minX = 0,\n        minY = 0,\n        l = matrix.length;\n\n    for (let i = 0; i < l; i++) {\n        // *2 speedup by restricting to the triangular matrix\n        for (let j = i + 1; j < l; j++) {\n            if (matrix[i][j] < min) {\n                min = matrix[i][j];\n                minX = i;\n                minY = j;\n            }\n        }\n    }\n\n    const a: InternalNode = {\n        profile: null as unknown as ProfPos,\n        childA: tabIdx[minX],\n        childB: tabIdx[minY],\n        distance: min,\n        estring: [],\n        msa: [],\n        numSeq: [],\n        type: NODE_TYPE.NODE,\n        depth: 0,\n        id: '',\n        tabWeight: [],\n        parent: -1,\n        weight: 0\n    };\n\n    return [a, minX, minY];\n}\n\nfunction recomputeDistMatrix(matrix: number[][], x: number, y: number, tI: number[]) {\n    const [lMax, lMin] = x > y ? [x, y]: [y, x];\n    const averages = [];\n    const l = matrix.length;\n\n    // loop matrix rows\n    for (var i = 0; i < l; i++) {\n        if (i == x || i == y) continue;\n\n        // avg computation from MAFFT\n        // When the distances between merged branches and the current one are\n        // dissimilar, this corrects the value towards the distance to the\n        // closest branch.\n\n        const avg = (\n            0.1 * (matrix[i][x] + matrix[i][y])) / 2\n            + 0.9 * Math.min(matrix[i][x], matrix[i][y]\n        );\n\n        // Add avg at the end of the row(i)\n\n        matrix[i].push(avg);\n\n        // collect the avg values to build the column\n\n        averages.push(avg);\n\n        // remove the cells at positions row(x) and row(y)\n\n        matrix[i].splice(lMax, 1);\n        matrix[i].splice(lMin, 1);\n    }\n\n    // the bottom of the future last column has the identity value (dist=0)\n\n    averages.push(0);\n\n    // Append column to matrix\n\n    matrix.push(averages);\n\n    // remove the values that were merged in averages\n\n    matrix.splice(lMax, 1);\n    matrix.splice(lMin, 1);\n    tI.splice(lMax, 1);\n    tI.splice(lMin, 1);\n\n    return matrix;\n}\n\n/**\n * Provides sequence weight following clustalw weighting scheme\n * From clwwt.cpp in MUSCLE (Edgar) :\n * Compute weights by the CLUSTALW method.\n    Thompson, Higgins and Gibson (1994), CABIOS (10) 19-29;\n    see also CLUSTALW paper.\n\n    Weights are computed from the edge lengths of a rooted tree.\n\n    Define the strength of an edge to be its length divided by the number\n    of leaves under that edge. The weight of a sequence is then the sum\n    of edge strengths on the path from the root to the leaf.\n\n    Example.\n\n            0.2\n           |-----A     0.1\n         --|x       |------- B     0.7\n           |--------|y          |----------- C\n            0.3     |-----------|z\n                        0.4     |-------------- D\n                                        0.8\n\n    | Edge\t|Length |Leaves |Strength|\n    | -----\t|------ |-------|--------|\n    | xy\t|0.3\t|\t3\t|\t0.1  |\n    | xA\t|0.2\t|\t1\t|\t0.2  |\n    | yz\t|0.4\t|\t2\t|\t0.2  |\n    | yB\t|0.1\t|\t1\t|\t0.1  |\n    | zC\t|0.7\t|\t1\t|\t0.7  |\n    | zD\t|0.8\t|\t1\t|\t0.8  |\n\n\n    | Leaf |   Path   | Strengths\t\t| Weight |\n    |------|----------| ----------------|--------|\n    |   A  | xA\t\t  | 0.2\t\t\t\t|  0.2   |\n    |   B  | xy-yB\t  | 0.1 + 0.1\t\t|  0.2   |\n    |   C  | xy-yz-zC | 0.1 + 0.2 + 0.7 |  1.0   |\n    |   D  | xy-yz-zD | 0.1 + 0.2 + 0.8 |  1.1   |\n\n    * @param   {object} cluster cluster tree computed\n    * @returns {array} array containing weights for each node in the cluster tree\n    */\n export function clustalWeights (cluster: Tree) {\n    const tabWeights: number[] = [];\n    let totalWeight = 0;\n    const root = cluster[cluster.length - 1];\n\n    function setWeight (node: LeafNode|InternalNode) {\n        var edgeLength = 0,\n            nbLeaves = 0;\n\n        switch (node.type) {\n        case NODE_TYPE.ROOT:\n            node.weight = 0;\n            setWeight(cluster[node.childA]);\n            setWeight(cluster[node.childB]);\n            break;\n        case NODE_TYPE.NODE:\n            edgeLength = cluster[node.parent].distance - node.distance;\n            nbLeaves = node.id.split(',').length;\n            node.weight = cluster[node.parent].weight + edgeLength / nbLeaves;\n\n            setWeight(cluster[node.childA]);\n            setWeight(cluster[node.childB]);\n            break;\n        case NODE_TYPE.LEAF:\n            edgeLength = cluster[node.parent].distance;\n            node.weight = cluster[node.parent].weight + edgeLength;\n            totalWeight += node.weight;\n            break;\n        }\n    };\n\n    setWeight(root);\n\n    //normalize weights to 1\n    // TODO: does is matter that internal nodes weights are not normalized?\n    var i = 0;\n    while (cluster[i].type == NODE_TYPE.LEAF) {\n        tabWeights[i] = cluster[i].weight /= totalWeight;\n        i++;\n    }\n\n    return tabWeights;\n};\n\n/**\n * Compare trees topologies. If the topologies are different, this procedure\n * copies over the msa from the subtress that are identical between treeA and\n * treeB.\n */\nexport function compareTrees (treeA: Tree, treeB: Tree) {\n    var i = 0,\n        nbLeaves = (treeA.length + 1) / 2 + 1, //chaque noeud possde deux descendants (peuvent tre un noeud ou une feuille). Le nombre de noeud est gal au nombre de feuilles -1\n        //nbNodes = nbLeaves - 1,\n\n        compareParentNodes = function (nodeA: InternalNode|LeafNode, nodeB: InternalNode|LeafNode) {\n            const lParentA = treeA[nodeA.parent];\n            const lParentB = treeB[nodeB.parent];\n\n            if (lParentA.id === lParentB.id) {  // Continue as long as canonical ids are identical\n\n                if (lParentB.msa.length > 0) { // This node has been visited\n                    return;\n                }\n\n                lParentB.msa = lParentA.msa;        // copy the MSA already computed to that node\n                lParentB.numSeq = lParentA.numSeq;  // Also copy the sequence order\n\n                if (lParentA.type !== NODE_TYPE.ROOT) { // Continue as long as root has not been reached\n                    compareParentNodes(lParentA, lParentB);\n                }\n            }\n        };\n\n    // When both trees have the same canonical ids to their roots, they are\n    // identical in topology.\n    if (treeA[treeA.length - 1].id === treeB[treeB.length - 1].id) {\n        return true;\n    }\n\n\n    /*\n        Otherwise, both trees must be compared pairwise to retain the alignments\n        that have already been computed.\n        Note : treeA and treeB have the same leaves, in the same order.\n        Traverse the trees in parallel, from the leaves to the root for as\n        long as the nodes topologies is identical.\n        By avoiding visited nodes, this procedure is O(n).\n    */\n    for (i = 0; i < nbLeaves; i++) {\n        compareParentNodes(treeA[i], treeB[i]);\n    }\n\n    return false;\n\n};\n\nexport function setProfiles (tree: Tree, pParam: TAlignmentParam, opt?: number) {\n    let i = 0;\n    let lNode = tree[i] as LeafNode;\n    while (isLeafNode(lNode) && i < tree.length) {\n        lNode.profile = seqToProf(lNode.seq, lNode.weight, pParam, opt);\n        i ++;\n        //@ts-expect-error node type could be InternalNode\n        lNode = tree[i];\n    }\n}\n","/**\n * @file progressive.alignment.ts\n * @author Paul Pillot <paul.pillot@libmol.org>\n * @license MIT\n * @copyright 2021\n * @description Controller for the optimal multiple alignment procedure\n * Most of this algorithm is inspired by R.C. Edgar MUSCLE library (a).\n *\n * (a) Edgar, R.C. MUSCLE: a multiple sequence alignment method with reduced\n * time and space complexity. BMC Bioinformatics 5, 113 (2004).\n * https://doi.org/10.1186/1471-2105-5-113\n *\n */\n\nimport { DEBUG, TAlignmentParam } from \"./params\";\nimport { TSequence, distanceMatrix, sortMSA } from \"../sequence/sequence\";\nimport { InternalNode, isLeafNode, makeTree, clustalWeights,\n    setProfiles} from \"../sequence/tree\";\nimport Log from '../utils/logger';\nimport { pairwiseAlignment, MSASeqAlignment, MSAMSAAlignment } from \"./align\";\nimport { estringProduct } from \"../utils/estring\";\nimport { mergeProfiles } from \"../sequence/profile\";\n\n\n\nexport function progressiveAlignment(seq: TSequence[], pParam: TAlignmentParam) {\n\n    // Recursive depth first tree based alignment\n    const treeAlign = (node: InternalNode, tabWeight: number[]) => {\n\n        const nodeA = tree[node.childA],\n              nodeB = tree[node.childB];\n        let result = {} as { score: number; };\n\n        // note: msa property has already been computed when the tree\n        // has had subtrees from a previous alignment, copied over.\n        // Then, they can be skipped to avoid costly computations.\n        if (!isLeafNode(nodeA) && (nodeA.msa.length === 0)) {\n            treeAlign(nodeA, tabWeight);\n        }\n\n        if (!isLeafNode(nodeB) && (nodeB.msa.length === 0)) {\n            treeAlign(nodeB, tabWeight);\n        }\n\n        // Now nodeA and nodeB are either leaf or msa, we can align them\n        if (isLeafNode(nodeA)) { //A is a single sequence\n            if (isLeafNode(nodeB)) { //B is a single sequence\n                const lR = pairwiseAlignment(nodeA.seq, nodeB.seq, pParam);\n                result.score = lR.score;\n\n                node.numSeq = [nodeA.numSeq[0], nodeB.numSeq[0]];\n                node.estring = lR.estrings;\n                node.profile = mergeProfiles(\n                    nodeA.profile,\n                    nodeB.profile,\n                    lR.estrings[0],\n                    lR.estrings[1],\n                    pParam\n                );\n\n                if (DEBUG)\n                    Log.add(`seq ${nodeA.numSeq} - seq ${nodeB.numSeq}`);\n\n            } else { //B is a MSA\n                nodeB.tabWeight = nodeB.numSeq.map(seqidx => tabWeight[seqidx]);\n\n                    // !!! B and A order are inverted\n\n                const lR = MSASeqAlignment(nodeB, nodeA, pParam);\n                result.score = lR.score;\n\n                    // !!! estrings[0] applies to nodeB\n\n                node.numSeq = [nodeA.numSeq[0], ...nodeB.numSeq];\n                node.estring = [\n                    lR.estrings[1],\n                    ...nodeB.estring.map(es => estringProduct(lR.estrings[0], es))\n                ];\n                node.profile = mergeProfiles(\n                    nodeA.profile,\n                    nodeB.profile,\n                    lR.estrings[1],\n                    lR.estrings[0],\n                    pParam\n                );\n\n                if (DEBUG)\n                    Log.add(`seq ${nodeA.numSeq} - MSA ${nodeB.numSeq}`);\n            }\n        } else if (!isLeafNode(nodeB)) { // A & B are both MSA\n\n            nodeB.tabWeight = nodeB.numSeq.map(seqidx => tabWeight[seqidx]);\n            nodeA.tabWeight = nodeA.numSeq.map(seqidx => tabWeight[seqidx]);\n\n            const lR = MSAMSAAlignment(nodeA, nodeB, pParam);\n            result.score = lR.score;\n\n            node.estring = [\n                ...nodeA.estring.map(es => estringProduct(lR.estrings[0], es)),\n                ...nodeB.estring.map(es => estringProduct(lR.estrings[1], es))\n            ];\n            node.profile = mergeProfiles(\n                nodeA.profile,\n                nodeB.profile,\n                lR.estrings[0],\n                lR.estrings[1],\n                pParam\n            );\n\n            if (DEBUG)\n                Log.add(`MSA ${nodeA.numSeq} - MSA ${nodeB.numSeq}`);\n        }\n        node.numSeq = [...nodeA.numSeq, ...nodeB.numSeq];\n\n        return result.score;\n    };\n\n    if (DEBUG)\n        Log.add('Start Progressive Alignment');\n\n    // Compute fast pair similarity (see k-mers binary Muscle)\n    const lDistMatrixKMers = distanceMatrix(seq);\n\n    if (DEBUG)\n        Log.add('K-mer distance matrix');\n\n    // Compute tree from distance matrix\n    const tree = makeTree(lDistMatrixKMers, seq);\n    const root = tree[tree.length - 1] as InternalNode;\n\n    if (DEBUG)\n        Log.add('Build Tree');\n\n    // Compute weights (this is used to prevent close sequences to skew\n    // the computation toward them, which would result in not disfavouring\n    // gaps in their already aligned sequences).\n    const weights = clustalWeights(tree);\n\n    if (DEBUG)\n        Log.add('Compute Weights - Start MSA');\n\n    setProfiles(tree, pParam);\n\n    // First alignment following guide tree\n    const score1 = treeAlign(root, weights);\n    let lEstrings = sortMSA(root.estring.slice(), root.numSeq);\n\n    if (DEBUG)\n        Log.add('End MSA computation');\n\n    return lEstrings;\n\n//================== For now, don't refine ====================\n\n    // Refinement.\n    // Now that we got a first alignment of all sequences, let see if some\n    // sequences have a better likeliness now than what was found in the\n    // first place with the fast k-mer based distance.\n    // First step: build a distance matrix based on identities, pondered\n    // using Kimura method for long branches (effective mutations are >\n    // to measured mutations)\n    // const lDistMatrixKimura = distanceKimura(msa);\n\n    // if (DEBUG)\n    //     Log.add('Distance Kimura');\n\n    // // compute new tree\n    // var tree2 = makeTree(lDistMatrixKimura, seq);\n    // const root2 = tree2[tree2.length - 1] as InternalNode;\n\n    // if (DEBUG)\n    //     Log.add('Build tree 2');\n\n    // // compare trees.\n    // // Note: Impure function, it will modify tree2 if differences are found\n    // // to take advantage of all the alignments already compared.\n    // var treeIdentity = compareTrees(tree, tree2);\n\n    // if (treeIdentity === true) { // No possible improvement\n    //     return msa;\n    // } else {\n    //     //Repeat progressive alignment along this new tree\n    //     var tabWeight2 = clustalWeights(tree2);\n\n    //     //$log.debug(tabWeight);\n    //     const score2 = treeAlign(root2, tabWeight2);\n\n    //     //$log.debug('scores:', score1, score2);\n    //     //var matriceDistancesKimura2 = _utils.distancesKimura(tree2[tree2.length - 1].msa);\n    //     if (score2 > score1) {\n    //         msa = sortMSA(root2.msa, root2.numSeq);\n    //     }\n    //     return msa;\n    // }\n\n}\n","/**\n * @file queue\n * @author Paul Pillot <paul.pillot@libmol.org>\n * @license MIT\n * @copyright 2021\n * @description Queue JS implementation\n *\n */\n\n/**\n * Double Ended Queue\n *\n * @export\n * @class DEQueue\n * @example let queue = new DEQueue(10);\n * queue.pushHead(1);\n * queue.pushHead(2);\n * let lTail = queue.popTail(); // lTail == 1\n * queue.size   // 1\n */\nexport class DEQueue<T>  {\n\n    store: T[]\n    head: number\n    tail: number\n    storeSize: number\n\n    constructor (size: number) {\n        this.storeSize = size\n        this.store = new Array(size)\n        this.head = 0;\n        this.tail = 0;\n    }\n\n    get size (): number {\n        return (this.tail - this.head + this.storeSize) % this.storeSize;\n    }\n\n    get isEmpty (): boolean {\n        return this.head === this.tail;\n    }\n\n    public popHead(): T|null {\n        if (this.isEmpty) return null;\n\n        const val = this.store[this.head];\n\n        this.head ++;\n        if (this.head >= this.storeSize) this.head = 0;\n\n        return val;\n    }\n\n    public popTail(): T|null {\n        if (this.isEmpty) return null;\n\n        this.tail --;\n        if (this.tail < 0) this.tail = this.storeSize - 1;\n\n        const val = this.store[this.tail];\n\n        return val;\n    }\n\n    public pushHead(val: T) {\n        this.head --;\n        if (this.head < 0) this.head = this.storeSize - 1;\n\n        this.store[this.head] = val;\n\n        // handle overflow by shifting tail\n        if (this.head === this.tail) {\n            this.tail = (this.tail - 1 + this.storeSize) % this.storeSize;\n        }\n    }\n\n    public pushTail(val: T) {\n\n        this.store[this.tail] = val;\n\n        this.tail ++;\n        if (this.tail >= this.storeSize) this.tail = 0;\n\n        //handle overflow by shifting head\n        if (this.head === this.tail) {\n            this.head = (this.head - 1 + this.storeSize) % this.storeSize;\n        }\n    }\n\n    public getHead(pos = 0): T {\n        const lIdx = pos === 0 ? this.head : (this.head + pos + this.storeSize) % this.storeSize;\n        return this.store[lIdx];\n    }\n\n    public getTail(pos = 0): T {\n        const lIdx = (this.tail - 1 - pos + this.storeSize) % this.storeSize;\n        return this.store[lIdx];\n    }\n}","/**\n * @file noalign\n * @author Paul Pillot <paul.pillot@libmol.org>\n * @license MIT\n * @copyright 2021\n * @description This module contains code to make a fast alignment computation\n * without doing the full Dynamic Programming routine as it is overexpensive\n * for long sequences, running in O(n2) time and space. For example aligning\n * a pair of mitochondrial DNA sequences (around 16kpb) requires 128MB for the\n * storage of the trace-back (TB) matrix.\n * It is noticeable that most of the TB is unused, and most of the DP\n * computations are useless when done in regions of low homology between\n * sequences.\n * To speed-up the process for long sequences, we'll try to restrict the DP\n * to the smallest regions possible. This entails to detect the regions where\n * the sequences are identical between sequences to anchor alignments from there\n * without doing any DP recursion.\n * Here is the proposed algorithm for aligning a pair of long genomic sequences\n * SeqA and SeqB:\n * -1. Extract minimizers from SeqA and SeqB and store them in hashes with their\n *     position and the actual sequence they minimize.\n *     Minimizers (Roberts 2004) are efficient constructs based on K-mers that\n *     store in a compressed way a longer sequence for allowing fast comparisons\n *     A K-mer is a substring of fixed length (for example 8 nucleotides).\n *     Storing and comparing all K-mers in a sequence is doable but takes time\n *     and space. A Minimizer is the K-mer with the minimal value in a larger\n *     window (for example a window of 30nt). The minimal value can be the\n *     lowest lexicographic order for example.\n *     If two sequences share an identical window of 30nt, they also share\n *     the same minimizer. Minimizers can be an order of magnitude less\n *     numerous than the exhaustive K-mers enumeration, and they allow to\n *     compare larger segments in one iteration.\n * -2. Find common minimizers and collect the ones minimizing common substrings\n *     At the end of this process a collection of ranges each associated with a\n *     diagonal has been established.\n * -3. Merge/filter ranges. Contiguous ranges on the same diagonal can be merged\n *     A range that is overlapped on its both sides by other ranges can be\n *     removed from the collection. REF to add here\n * -4. Find an optimal order of the remaining diagonals (similarly to a\n *     Longest Increasing Sequence problem).\n * -5. Extend diagonals with exact and approximate matches\n * -6. Solve alignments between diagonals using the DP method (should be very\n *     fast then as the remaining DP matrices should be a fraction of the\n *     initial one)\n *\n *\n * (a) Roberts M. et al. BIOINFORMATICS Vol. 20 no. 18 2004, pages 33633369\n * doi:10.1093/bioinformatics/bth408 - Reducing storage requirements for\n * biological sequence comparison\n *\n */\n\nimport { TSequence } from \"../sequence/sequence\";\nimport { DEQueue } from '../utils/queue';\nimport { DEBUG, TAlignmentParam } from \"./params\";\nimport Log from \"../utils/logger\";\nimport { hammingWeight } from \"../utils/bitarray\";\nimport { ALIGNOPT, pairwiseAlignment } from \"./align\";\nimport { epath2estring, EPATH_2_STRING, estringCat, estringCountPositive,\n    estringDifference, estringLength, estringMerge, estringProduct } from \"../utils/estring\";\n\ntype TRange = {\n    /** diagonal number. 0 is the main diagonal. negative numbers are diagonals\n     * shifted towards sequence B (gaps inserted in B). Positive numbers are\n     * diagonals shifted towards sequence A (gaps inserted in A)\n     */\n    diagId: number,\n    /** X axis (sequence A is the reference for this axis) coordinate for the\n     * start (top tip) of this diagonal\n     */\n    begin: number,\n    /** X axis coordinate fot the end (bottom tip) of this diagonal */\n    end: number\n};\n\n/** A missing segment is the zone defined between the end points of two\n * successive diagonals */\ntype TMissingSegment = {\n    beginDiagId: number,\n    endDiagId: number,\n    begin: number,\n    end: number\n}\n\ntype TMinzStore = {\n    /** Vector of minimizing kmers found in sequence */\n    kmer: Uint16Array,\n    /** Start position in sequence of kmer at same index in vector `kmer` */\n    kmerPos: Uint16Array,\n    /** Start position of the window minimized by kmer at same index in vector `kmer` */\n    winPos: Uint16Array,\n    /** End position of the window minimized by kmer at same index in vector `kmer` */\n    winPosEnd: Uint16Array,\n    /** Number of minimizers found in store */\n    count: number\n}\n\nconst KSIZE = 8;    // fits in 16bits\nconst WSIZE = 24;   // empirical\nconst EXTENSION_THRESHOLD = KSIZE/4; // don't extend when more than 25% difference\n\n\n/**\n * Given a sequence, computes its kmers and extracts the subset of\n * kmers that are minimizers (kmer with minimal value) in a sliding window.\n *\n * @export\n * @param {TSequence} seq Sequence object\n *\n * @see https://doi.org/10.1093/bioinformatics/btaa435 Chirag Jain, Arang Rhie,\n * Haowen Zhang, Claudia Chu, Brian P Walenz, Sergey Koren, Adam M Phillippy,\n * Weighted minimizer sampling improves long read mapping, Bioinformatics,\n * Volume 36, Issue Supplement_1, July 2020, Pages i111i118\n */\nexport function extractMinimizers (seq: TSequence, ksize: number, wsize: number): TMinzComp {\n\n    const lMinzMap: Map<number, number[]> = new Map();\n    const lQueue = new DEQueue<number>(wsize);\n    const lKSIZE = ksize | 0;\n\n        // Create an array of 8-kmers from sequence\n        // 8-kmers, with 2 bits per letter in a 4 letter alphabet require 16\n        // bits. Let's compute it using a sliding window (in O(n) )\n\n    const lKarr = new Uint16Array(seq.encodedSeq.length - lKSIZE + 1);\n    let kval = 0|0;\n    let lIdx = 0;\n    for (let i = 0; i < lKSIZE; i++) {\n        kval |= seq.encodedSeq[lKSIZE - i - 1] << (i * 2);\n    }\n    lKarr[lIdx++] = kval;\n\n    for (let i = lKSIZE, imax = seq.encodedSeq.length; i < imax; i++) {\n        kval = (kval << 2) + seq.encodedSeq[i];\n        lKarr[lIdx++] = kval;\n    }\n\n        // Compute minimizers\n\n    const lStartStore = wsize - lKSIZE;\n\n        // random kmer density is 2/(wsize + 1). This doubles the expected size\n        // for the store.\n\n    const lLength = (seq.rawSeq.length * (2 / (wsize + 1)) * 2)|0 ;\n    const lStoreMinz: TMinzStore = {\n        kmer     : new Uint16Array(lLength),\n        kmerPos  : new Uint16Array(lLength),\n        winPos   : new Uint16Array(lLength),\n        winPosEnd: new Uint16Array(lLength),\n        count: 0\n    };\n    let lCurrMinzPos = NaN;\n    let j = 0;\n    let lWinStart = - lStartStore - 1;\n\n        // Main loop for minimizer computation.\n        // i is indexing kmers. The kmer at index i is considered to be the\n        // kmer entering in the sliding window.\n        // The sliding window starts at i - window length + kmer length as Kmer(i)\n        // is part of the window.\n        // Computing the minimizer of the sliding window is finding the kmer with\n        // the lowest value in this window.\n        // This is done using a deque where kmers entering the window (kmer(i))\n        // are appended to the tail and remove all kmers at the tail that are of\n        // higher value. This maintains a sorting of kmers in the deque.\n        // Hence the deque head contains the kmer with minimal value.\n\n    for (let i = 0; i < lKarr.length; i++) {\n        const lKmer = lKarr[i];\n        lWinStart++;\n\n            // Remove kmers with lower order than current kmer\n            // Note: for sake of symplicity, order is just kmer value.\n\n        while (!lQueue.isEmpty\n            && (\n                (j = lQueue.getTail()) < lWinStart  // not in this window anymore\n                || lKarr[j] >= lKmer                // can't be a minimizer of this and future windows: overthrown by kmer(i)\n            )\n        ){\n            lQueue.popTail();\n        }\n\n            // Append current kmer to tail\n\n        lQueue.pushTail(i);\n\n        if (lWinStart < 0) continue;  // compute all kmers in first window first\n\n            // Remove kmers that are not in this window anymore\n\n        while (lQueue.getHead() < lWinStart) {\n            lQueue.popHead();\n        }\n\n            // Store head kmer in minimizer hash\n\n        let lHead = lQueue.getHead();\n\n            // Is it the same minimizer as in previous loop iteration?\n            // If yes, only extend the minimized subarray\n\n        if (lHead === lCurrMinzPos) {\n            lStoreMinz.winPosEnd[lStoreMinz.count - 1] = i + lKSIZE;\n        } else {\n            const lHeadKmer = lKarr[lHead];\n            const lIdx = lStoreMinz.count;\n            lStoreMinz.count ++;\n\n            lStoreMinz.kmer     [lIdx] = lHeadKmer;\n            lStoreMinz.kmerPos  [lIdx] = lHead;\n            lStoreMinz.winPos   [lIdx] = lWinStart;\n            lStoreMinz.winPosEnd[lIdx] = i + lKSIZE;\n            lCurrMinzPos = lHead;\n\n                // Add the kmer to the map, either as a new list or as a new\n                // item in a previous list (when the same kmer also minimizes\n                // another window)\n\n            if (!lMinzMap.has(lHeadKmer)) {\n                lMinzMap.set(lHeadKmer, [lIdx]);\n            } else {\n                let lList = lMinzMap.get(lHeadKmer) as number[];\n                lList.push(lIdx);\n            }\n\n        }\n\n    }\n\n    return [lMinzMap, lStoreMinz, lKarr];\n}\n\n/** Map Kmer value to a table of all its indices in the sequence */\ntype TMinzMap = Map<number, number[]>;\ntype TMinzComp = [TMinzMap, TMinzStore, Uint16Array];\n\nexport function noalignPair(\n    seqA: TSequence,\n    seqB: TSequence,\n    pAlignParam: TAlignmentParam,\n    pMinzA?: TMinzComp,\n    pMinzB?: TMinzComp\n) {\n\n    let lDebugStats: {[k: string]: Partial<{a: any, b: any, all: any}>} = {};\n\n    const [lMinzA, lMinzAStore, lKmerAArr] = pMinzA ?? extractMinimizers(seqA, KSIZE, WSIZE);\n    const [lMinzB, lMinzBStore, lKmerBArr] = pMinzB ?? extractMinimizers(seqB, KSIZE, WSIZE);\n    if (DEBUG) {\n        Log.add('Extract Minimizers');\n        lDebugStats['Nb Minimizers'] = {a: lMinzAStore.count, b: lMinzBStore.count};\n        lDebugStats['Dupl. Minimizers'] = {a: lMinzAStore.count - lMinzA.size, b: lMinzBStore.count - lMinzB.size};\n    }\n\n    let lNbCommonWindows = 0;\n    const lMaxLen = Math.max(seqA.rawSeq.length, seqB.rawSeq.length);\n    const lDiagMap = new Map<number, TRange[]>();\n\n    // Loop through all kmers fron sequence A to find which ones are matching\n    // in sequence B. Doing so, favour the kmers that minimize a common window.\n    // Those are better seed candidates for diagonals. They also cover a longer\n    // range and thus avoid extra computations.\n\n    for (let i = 0; i < lMinzAStore.count; i++) {\n        let kmer = lMinzAStore.kmer[i];\n\n        if (!lMinzB.has(kmer)) continue;\n        let listB = lMinzB.get(kmer) as number[];\n        if (listB.length > 4) continue; // poor minimizer. prevent combinatorial explosion\n\n            // Compare minimized string in A with those in listB to take advantage of\n            // the ones that share common minimized strings\n\n        let lMinzSubA = seqA.rawSeq.substring(lMinzAStore.winPos[i], lMinzAStore.winPosEnd[i]);\n\n        for (let j = 0; j < listB.length; j++) {\n            let lBidx = listB[j];\n            let lMinzSubB =  seqB.rawSeq.substring(lMinzBStore.winPos[lBidx], lMinzBStore.winPosEnd[lBidx]);\n            let lLen = Math.min(lMinzSubA.length, lMinzSubB.length);\n\n            let lHasCommonWindow = false;\n            if (lLen == lMinzSubA.length) {\n                   lHasCommonWindow = (lMinzSubB.indexOf(lMinzSubA) === 0);\n            } else lHasCommonWindow = (lMinzSubA.indexOf(lMinzSubB) === 0);\n\n            // common range to store\n            let lDiagId = 0;\n            let lRange: TRange;\n            if (lHasCommonWindow) {\n                lDiagId = lMinzAStore.winPos[i] - lMinzBStore.winPos[lBidx];\n                lRange = {\n                    diagId: lDiagId,\n                    begin : lMinzAStore.winPos[i],\n                    end   : lMinzAStore.winPos[i] + lLen\n                };\n                lNbCommonWindows ++;\n            } else {\n                lDiagId = lMinzAStore.kmerPos[i] - lMinzBStore.kmerPos[lBidx];\n                lRange = {\n                    diagId: lDiagId,\n                    begin : lMinzAStore.kmerPos[i],\n                    end   : lMinzAStore.kmerPos[i] + KSIZE - 1\n                };\n            }\n\n\n            if (!lDiagMap.has(lDiagId)) {\n                lDiagMap.set(lDiagId, [lRange]);\n            } else {\n                let lDiagList = lDiagMap.get(lDiagId);\n                lDiagList!.push(lRange);\n            }\n        }\n    }\n    if (DEBUG) {\n        Log.add('Filter Common Minimizers');\n        lDebugStats['Nb common windows'] = { all: lNbCommonWindows };\n    }\n\n    let lDiagList: TRange[] = [];\n    // Merge consecutive or overlapping subarrays on the same diagonals\n    // Note: the extensions are made on range references\n    lDiagMap.forEach((diags) => {\n        if (!diags.length) return;  // safeguard\n\n        let lCurrentSegment = diags[0];\n        lDiagList.push(lCurrentSegment);\n        diags.forEach(range => {\n            if (range.begin <= lCurrentSegment.end) {\n                lCurrentSegment.end = range.end;\n            } else {\n                lCurrentSegment = range;\n                lDiagList.push(lCurrentSegment);\n            }\n        });\n    });\n    if (DEBUG) {\n        Log.add('Merge Minimizers');\n        lDebugStats['Nb diagonals'] = {all: lDiagList.length};\n    }\n\n    // Special case: no diagonal found: fallback to NW alignment\n    if (lDiagList.length === 0) {\n        if (DEBUG) console.table(lDebugStats);\n\n        return pairwiseAlignment(seqA, seqB, pAlignParam).estrings;\n    }\n\n    // Sort ranges in diag list from left to right and from top to bottom\n    lDiagList.sort((a, b) => {\n        let lDelta = a.begin + a.diagId - b.begin - b.diagId;\n        return (lDelta === 0) ? a.diagId - b.diagId: lDelta;\n    });\n    if (DEBUG) Log.add('Sort Minimizers');\n\n    lDiagList = extractLongestPath(lDiagList, seqA.encodedSeq.length, seqB.encodedSeq.length);\n\n    if (DEBUG) {\n        Log.add('Filter Minimizers - Optimal list');\n        let lCoverage = 0;\n        lDiagList.forEach(d => {\n            lCoverage += d.end - d.begin;\n        });\n        lCoverage /= lMaxLen;\n        lDebugStats['Strict Coverage'] = {all: lCoverage};\n\n        lDebugStats['Nb filtered diagonals'] = {all: lDiagList.length};\n    }\n\n    // Extend consecutive segments on same diagonal. We apply a tolerance for\n    // extension at 25% difference between Kmers.\n    // This is measured by bitwise operations between 16bits numbers.\n\n    let lPrevSegment: TRange = { diagId: 0, begin: 0, end: 0 } //lDiagList[0];\n    let lExtDiagList = [lPrevSegment];\n    let lMissingSegments: TMissingSegment[] = [];\n\n    for (let i = 0; i < lDiagList.length; i++) {\n        let lCurrentSegment = lDiagList[i];\n\n        // TODO: when difference between end and begin is >> KSIZE (e.g. 400),\n        // there are likely unmapped gaps. It might be useful to speed up\n        // matches using shorter Kmers/windows. Test the overhead + noise\n        // generated.\n\n        // first case: this segment is on the same diagonal as the previous one\n        // Try to extend begin position towards previous segment.\n\n        if (lCurrentSegment.diagId === lPrevSegment.diagId) {\n            // Compare kmers in forward direction until score drops\n            let m = lPrevSegment.end;   // end position on seq A\n            let n = m - lCurrentSegment.diagId;\n            let lWinScore = 0;\n\n            while (m < lCurrentSegment.begin\n                && n < lCurrentSegment.begin - lCurrentSegment.diagId\n                && lWinScore < 2\n            ) {\n                m += KSIZE;\n                n += KSIZE;\n                lWinScore = dnaHammingDistance(lKmerAArr[m], lKmerBArr[n]) <= EXTENSION_THRESHOLD ? 0 : lWinScore + 1;\n            }\n\n            // To avoid boundaries conditions, remove the tip of the extension\n            if (m > lPrevSegment.end) {\n                lPrevSegment.end = Math.max(m - EXTENSION_THRESHOLD - KSIZE, lPrevSegment.end);\n            }\n\n            // Compare in backward direction until score drops or merge has been\n            // achieved\n\n            m = lCurrentSegment.begin - KSIZE;\n            n = m - lCurrentSegment.diagId;\n            lWinScore = 0;\n// WIP Make stats on full window, not just 1 Kmer\n            while (m > lPrevSegment.end\n                && n > lPrevSegment.end - lPrevSegment.diagId\n                && lWinScore < 2\n            ) {\n                m -= KSIZE;\n                n -= KSIZE;\n                lWinScore = dnaHammingDistance(lKmerAArr[m], lKmerBArr[n]) <= EXTENSION_THRESHOLD ? 0 : lWinScore + 1;\n            }\n//TODO: check this, the Maths look dubious\n            if (m < lCurrentSegment.begin - 2 * KSIZE) {\n                lCurrentSegment.begin = m + 3 * KSIZE + EXTENSION_THRESHOLD;\n            }\n\n            // merge?\n            if (lCurrentSegment.begin - lPrevSegment.end <= 3 * KSIZE) {\n                lPrevSegment.end = lCurrentSegment.end;\n                continue;\n            } else {\n                lMissingSegments.push({\n                    beginDiagId: lPrevSegment.diagId,\n                    endDiagId: lCurrentSegment.diagId,\n                    begin: lPrevSegment.end,\n                    end: lCurrentSegment.begin\n                });\n                lExtDiagList.push(lCurrentSegment);\n                lPrevSegment = lCurrentSegment;\n                continue;\n            }\n        } else {\n            // Compare nucleotides in forward direction until they differ\n            let m = lPrevSegment.end;   // end position on seq A\n            let n = m - lPrevSegment.diagId;\n\n            while (seqA.encodedSeq[m] === seqB.encodedSeq[n]\n                && m < lCurrentSegment.begin\n                && n < lCurrentSegment.begin - lCurrentSegment.diagId\n            ) {\n                m ++;\n                n ++;\n            }\n\n            lPrevSegment.end = m;   // last before discrepancy. This position is\n                                    // exclusive in the prevSegment, and inclusive\n                                    // in the missing segment if any.\n\n            // Compare in backward direction until sequences differ\n\n            m = lCurrentSegment.begin;\n            n = m - lCurrentSegment.diagId;\n\n            while (seqA.encodedSeq[m] === seqB.encodedSeq[n]\n                && m > lPrevSegment.end\n                && n > lPrevSegment.end - lPrevSegment.diagId\n            ) {\n                m --;\n                n --;\n            }\n\n            lCurrentSegment.begin = m + 1;  // last before discrepancy\n\n            lMissingSegments.push({\n                endDiagId: lCurrentSegment.diagId,\n                beginDiagId: lPrevSegment.diagId,\n                begin: lPrevSegment.end,\n                end: lCurrentSegment.begin\n            });\n            lExtDiagList.push(lCurrentSegment);\n            lPrevSegment = lCurrentSegment;\n        }\n    }\n\n    if (DEBUG) {\n        Log.add('Diagonals extension');\n        let lCoverage = 0;\n        lExtDiagList.forEach(d => {\n            lCoverage += d.end - d.begin;\n        });\n        lCoverage /= lMaxLen;\n        lDebugStats['Coverage'] = {all: lCoverage};\n        lDebugStats['Extended Diagonals'] = {all: lExtDiagList.length};\n        console.table(lDebugStats);\n\n        //console.table(lMissingSegments);\n    }\n\n    // Make the alignment from the diagonals and fill the gaps\n    let lDiag = lExtDiagList[0];\n    const lEpathA: number[] = [];\n    const lEpathB: number[] = [];\n    for (let i = 0; i < lExtDiagList.length; i++) {\n        lDiag = lExtDiagList[i];\n        lEpathA.push(lDiag.end - lDiag.begin);\n        lEpathB.push(lDiag.end - lDiag.begin);\n\n        let lMis = lMissingSegments[i];\n        if (lMis) {\n            // Special case next diag begins at same col prev diag finishes\n            if (lMis.begin === lMis.end) {\n                const lDelta = Math.abs(lMis.endDiagId - lMis.beginDiagId);\n                lEpathA.push(-lDelta);\n                lEpathB.push(lDelta);\n                continue;\n            }\n\n            // Special case next diag begins at same row prev diag finishes\n            if (lMis.begin - lMis.beginDiagId === lMis.end - lMis.endDiagId) {\n                const lDelta = lMis.end - lMis.begin;\n                lEpathB.push(-lDelta);\n                lEpathA.push(lDelta);\n                continue;\n            }\n\n\n            let lResult = pairwiseAlignment({\n                rawSeq: seqA.rawSeq.substring(lMis.begin, lMis.end),\n                type: seqA.type,\n                compressedSeq: new Uint8Array(0),\n                encodedSeq: seqA.encodedSeq.subarray(lMis.begin, lMis.end)\n            }, {\n                rawSeq: seqB.rawSeq.substring(lMis.begin - lMis.beginDiagId, lMis.end - lMis.endDiagId),\n                type: seqB.type,\n                compressedSeq: new Uint8Array(0),\n                encodedSeq: seqB.encodedSeq.subarray(lMis.begin - lMis.beginDiagId, lMis.end - lMis.endDiagId)\n            }, pAlignParam,\n            ALIGNOPT.DISABLE_FAVOR_END_GAP | ALIGNOPT.DISABLE_FAVOR_START_GAP);\n\n            lEpathA.push(...lResult.estrings[0]);\n            lEpathB.push(...lResult.estrings[1]);\n        }\n\n    }\n\n        // Append tail if any\n        // At this stage both aligned sequences have the same length.\n        // For now, just append the missing part. Ultimately, assess, depending\n        // on the tail length if a SW alignmnent is deemed necessary.\n\n    sanitizeEpathEnd(lEpathA, seqA.encodedSeq.length);\n    sanitizeEpathEnd(lEpathB, seqB.encodedSeq.length);\n\n    let lEstringA = epath2estring(lEpathA, EPATH_2_STRING.NO_REVERSE);\n    let lEstringB = epath2estring(lEpathB, EPATH_2_STRING.NO_REVERSE);\n\n    const lEszA = estringLength(lEstringA);\n    const lEszB = estringLength(lEstringB);\n    if (lEszA > lEszB) lEstringB = estringCat(lEstringB, [lEszB - lEszA]);\n    else if (lEszA < lEszB) lEstringA = estringCat(lEstringA, [lEszA - lEszB]);\n\n    if (DEBUG) {\n        Log.add('Fill between diagonals');\n    }\n\n    // TODO: Finalize alignment here\n    return [lEstringA, lEstringB];\n}\n\n/**\n * Given an epath, it ensures that the sum of its positive values equals the\n * target length.\n *\n * @param {number[]} epath\n * @param {number} targetLength\n */\nfunction sanitizeEpathEnd(epath: number[], targetLength: number) {\n    let lCount = estringCountPositive(epath);\n    let lDelta = targetLength - lCount;\n    if (lDelta > 0) epath.push(lDelta);\n    else if (lDelta < 0) epath[epath.length - 1] += lDelta;\n}\n\n/**\n * Returns the number of different letters in DNA alphabet between 2 kmers\n * encoded as numbers, using bitwise operations\n *\n * @param {number} a\n * @param {number} b\n */\nexport function dnaHammingDistance (a: number, b: number) {\n\n    // DNA alphabet encodes 4 symbols using 2 bits. In the following, we'll\n    // count the pairs of bits that are different between a and b.\n    let c = a ^ b;  // set bit for pair of bits that are different\n    c = (c & 0x55555555) | ((c >> 1) & 0x55555555); // intersect with 010101... to retain only the lowest bit in each pair\n    return hammingWeight(c);\n\n}\n\n/**\n * Align multiple (long) sequences using the center-star method.\n *\n * @export\n * @param {TSequence[]} pSeq\n * @param {TAlignmentParam} pAlignParam\n * @returns\n */\nexport function centerStarNoAlign(pSeq: TSequence[], pAlignParam: TAlignmentParam) {\n\n    let lMinz = pSeq.map(seq => { return extractMinimizers(seq, KSIZE, WSIZE) });\n\n    // TODO: find center sequence\n    let lCenter = 0;\n    let lEStrings: number[][] = [];\n    let lCenterEString: number[] = [];\n    let lCenterEStringRaw: number[][] = [];\n\n    for (let i = 0; i < lMinz.length; i++) {\n        if (i === lCenter) continue;\n\n        let lEsAln = noalignPair(pSeq[lCenter], pSeq[i], pAlignParam, lMinz[lCenter], lMinz[i]);\n\n        // Center Edit strings combines the Edit strings from the alignment to the\n        // current sequence with its previous edit strings.\n        lCenterEString = lCenterEString.length === 0\n            ? lEsAln[0]\n            : estringMerge(lCenterEString, lEsAln[0]);\n\n        // Keep track of what was this alignment edit string for center sequence\n        // This is used to make a diff, at next iteration.\n        lCenterEStringRaw[i] = lEsAln[0];\n\n        // Edit string to align this sequence with the center. It will be\n        // modified to account for other sequences introduced editions\n        lEStrings[i] = lEsAln[1];\n    }\n\n    for (let i = 0; i < lMinz.length; i++) {\n        if (i === lCenter) {\n            lEStrings[i] = lCenterEString;\n            continue;\n        }\n        let lDiff = estringDifference(lCenterEString, lCenterEStringRaw[i]);\n        if (!lDiff) {\n            console.error('An error occured while computing the center diff. for sequence #' + i, lCenterEString, lCenterEStringRaw[i]);\n            console.dir(lEStrings)\n            console.dir(lCenterEStringRaw)\n            throw new RangeError();\n        }\n        lEStrings[i] = estringProduct(lDiff, lEStrings[i]);\n    }\n\n    return lEStrings;\n\n}\n\n/**\n * Find an optimal order of traversal among a list of diagonals so that they\n * make the longest past covered by diagonals in the alignment matrix between\n * both sequences.\n * @param pDiagList list of diagonals ordered from left to right and top to\n *                  bottom\n * @param lMaxLen   maximum sequence length. Used to compute a minimal gap\n *                  penalty\n * @returns\n */\nfunction extractLongestPath (pDiagList: TRange[], pLenA: number, pLenB: number) {\n\n    /* Find optimal order of diagonals using Longest Increasing Sequence\n       like algorithm. Here, the Word Sequence is replaced by Suite so as to\n       avoid confusion with biological sequences.\n       In the context of diagonals, a new diagonal can be appended to a list\n       iff it is in the SW quadrant from the bottom tip of the last diagonal\n       in the list.\n       ____________________________________________________________________\n       |              \\\n       |  \\            \\ B\n       |   \\ A          \\\n       |    \\                 \\\n       |                       \\ C\n       |                        \\\n\n       C can extend B but it can't extand A\n\n       A new diagonal can start a new list if:\n       - its diag id is > to the one of the current shorter list in the suites\n         (the rationale is that any diagonal that would extend a diagonal below\n         the smallest one would also be an extension of the smallest one)\n       - and its row (defined by begin - diag id) is lower.\n         (the rationale is that this new diagonal will be able to catch next\n         diagonals that can't be caught by the current minimum)\n       - or if this diagonal by itself long enough to be the optimum while not\n         being able to be appended to any other list.\n\n       Otherwise, we search for the list of diagonals with maximum size that can\n       accept the new diagonal and we duplicate it + append the new diagonal to\n       it. The new suite is placed in the list of suit so that the order of\n       increasing sizes is maintained.\n       When this addition is made, the list of suites is cleaned to remove any\n       list that is shorter and that also extends past this new extent (in other\n       words a diagonal that extends past, is a diagonal which bottom tip is\n       below the lowest point of the new diagonal).\n    */\n\n    const lUnitPenalty = 1/Math.max(pLenA, pLenB);\n    const lDividerDiag = pLenA - pLenB;\n\n    /** Collections of list of increasing diagonals */\n    let lIncreasingPaths: number[] = [0];\n    /** Stores at the index corresponding to each diagonal, the index of its\n     * preceding diagonal\n     */\n    let lTraceBack = new Int16Array(pDiagList.length);\n    lTraceBack[0] = -1; // starts a path\n\n    /** The current diag in the list */\n    let lDiag = pDiagList[0];\n    /** Diagonal length. What it will add to the score of the path it may be appended to */\n    let lDiagLen = lDiag.end - lDiag.begin;\n    /** Bottom row the diagonal extends to. It's the end posision of the segment in the Sequence B */\n    let lDiagBottomRow = lDiag.end - lDiag.diagId;\n    /** Top row the diagonal begins at. It's the start posision of the segment in the Sequence B */\n    let lDiagTopRow = lDiag.begin - lDiag.diagId;\n    let lDiagDistToEnd = Math.min(pLenB - lDiagBottomRow, pLenA - lDiag.end);\n    /** Length of each list of increasing diagonals as the sum of diags length */\n    let lPathsScores: number[] = [lDiagLen];\n    /** Y position of the tip of the path */\n    let lPathsBottomRow: number[] = [lDiagBottomRow];\n\n    let lPathsDistToEnd = [lDiagDistToEnd];\n    /** Reference to current minimum in list of paths */\n    let lMinDiag = pDiagList[0];\n    let lMaxDiagId = 0;\n    let lMaxDiag = pDiagList[lMaxDiagId];\n    let lOptimumScore = lDiagLen;\n\n    let lGCCount = 0;\n\n    for (let i = 1; i < pDiagList.length; i++) {\n        lDiag = pDiagList[i];\n        lDiagLen = lDiag.end - lDiag.begin;\n        lDiagBottomRow = lDiag.end - lDiag.diagId;\n        lDiagTopRow = lDiag.begin - lDiag.diagId;\n        lDiagDistToEnd = lDiag.diagId < lDividerDiag ? pLenB - lDiagBottomRow : pLenA - lDiag.end;\n\n            // Garbage Collection\n\n        if (lGCCount === 20) {\n            lGCCount = 0;\n            let lGarbageIdx: number[] = [];\n            let k = lIncreasingPaths.length - 1;\n            let lPrevBottom = lPathsBottomRow[k];\n            let lRemainingDist = pLenA - lDiag.begin;\n\n                // clean paths array by removing all paths:\n                // - that extend below higher scoring path\n                // - that score too low for ever being in an optimal path\n\n            while (k --) {\n                if (lPathsBottomRow[k] > lPrevBottom) {\n                    lGarbageIdx.push(k);\n                    continue;\n                }\n\n                lPrevBottom = lPathsBottomRow[k];\n\n                if (lPathsScores[k] + Math.min(lPathsDistToEnd[k], lRemainingDist) < lOptimumScore) {\n                    lGarbageIdx.push(k);\n                }\n            }\n\n            lGarbageIdx.forEach((k) => {\n                lIncreasingPaths.splice(k, 1);\n                lPathsScores.splice(k, 1);\n                lPathsBottomRow.splice(k, 1);\n                lPathsDistToEnd.splice(k, 1);\n            });\n\n\n        }\n\n        if (lDiag.diagId >= lMinDiag.diagId     // diagonals below the minimum can't be a candidate for a new minimum\n            && lDiagBottomRow < lPathsBottomRow[0]    // diagonal tip row must be above current minimum\n        ) {\n\n            if (lDiagLen + lDiagDistToEnd < lOptimumScore) continue;\n\n            lTraceBack[i] = -1;\n            lMinDiag = pDiagList[i];\n            lGCCount ++;\n\n            if (lDiagLen < lPathsScores[0]) {\n                lIncreasingPaths.unshift(i);\n                lPathsScores    .unshift(lDiagLen);\n                lPathsBottomRow .unshift(lDiagBottomRow);\n                lPathsDistToEnd .unshift(lDiagDistToEnd);\n                continue;\n            }\n\n            if (lDiagLen > lOptimumScore) lOptimumScore = lDiagLen;\n            lIncreasingPaths[0] = i;\n            lPathsScores    [0] = lDiagLen;\n            lPathsBottomRow [0] = lDiagBottomRow;\n            lPathsDistToEnd [0] = lDiagDistToEnd;\n            continue;\n        }\n\n        // Loop over the list of increasing sequences and see to which one this\n        // diagonal could be appended to.\n\n        for (let j = lIncreasingPaths.length - 1; j >= 0; j--) {\n            lMaxDiagId = lIncreasingPaths[j];\n            lMaxDiag = pDiagList[lMaxDiagId];\n            if (lDiag.begin >= lMaxDiag.end\n                && lPathsBottomRow[j] < lDiagTopRow      // New must be SW of latest\n            ) {\n\n                    // This small gap penalty favours diagonals that extend a\n                    // list with the lowest jump. It should only have an effect\n                    // when there is a tie between short diagonals\n\n                const lGapPenalty = Math.abs(lDiag.diagId - lMaxDiagId) * lUnitPenalty;\n                const lNewSize = lPathsScores[j] + lDiagLen - lGapPenalty;\n\n                if (lNewSize + lDiagDistToEnd < lOptimumScore) continue;    // no hope for being a future optimimum\n\n                // TODO: binary search to find where it should be inserted now\n                let k = j;\n                while (k < lIncreasingPaths.length && lPathsScores[k] < lNewSize) {\n                    k ++;\n                }\n\n                if (k === lIncreasingPaths.length) {\n                    lOptimumScore = lNewSize;\n\n                    lPathsDistToEnd .push(lDiagDistToEnd);\n                    lPathsScores    .push(lNewSize);\n                    lPathsBottomRow .push(lDiagBottomRow);\n                    lIncreasingPaths.push(i);\n                } else {\n                    if (lDiagBottomRow >= lPathsBottomRow[lPathsBottomRow.length - 1]) continue;\n\n                    lPathsDistToEnd .splice(k, 0, lDiagDistToEnd);\n                    lPathsScores    .splice(k, 0, lNewSize);\n                    lPathsBottomRow .splice(k, 0, lDiagBottomRow);\n                    lIncreasingPaths.splice(k, 0, i);\n                }\n\n                lTraceBack[i] = lMaxDiagId;\n                lGCCount ++;\n\n                break;\n            }\n        }\n\n            // special case: the diagonal is an optimal path in itself\n\n        if (lDiagLen > lOptimumScore) {\n            lTraceBack[i] = -1;\n            lOptimumScore = lDiagLen;\n            lPathsDistToEnd .push(lDiagDistToEnd);\n            lPathsScores    .push(lDiagLen);\n            lPathsBottomRow .push(lDiagBottomRow);\n            lIncreasingPaths.push(i);\n\n            lGCCount++;\n        }\n    }\n\n    let lPath = [];\n    let k = lIncreasingPaths.pop() ?? 0;\n    let lSafeguard = k;\n    while (k > -1 && lSafeguard > -1) {\n        lPath.push(k);\n        k = lTraceBack[k];\n        lSafeguard --;\n    }\n\n    let lLongestPath: TRange[] = [];\n    for (let i = lPath.length - 1; i >=0; i--) {\n        lLongestPath.push(pDiagList[lPath[i]]);\n    }\n    return lLongestPath;\n}\n","/**\n * @file index\n * @author Paul Pillot <paul.pillot@libmol.org>\n * @license MIT\n * @copyright 2020-2021\n */\n\nimport {\n    makeSequence,\n    getSequenceType,\n    TSequence,\n} from './sequence/sequence';\nimport { DEBUG, SEQUENCE_TYPE, getAlignmentParameters, DEFAULT_GAP_CHAR } from './align/params';\nimport { pairwiseAlignment } from './align/align';\nimport { progressiveAlignment } from \"./align/progressive.alignment\";\nimport Log from './utils/logger';\nimport { centerStarNoAlign, noalignPair } from './align/noalign';\nimport { applyEstring } from './utils/estring';\n\ntype TAlignMethod = 'diag'|'complete'|'auto';\ntype TAlignSequenceType = 'amino'|'nucleic'|'auto';\nexport type TAlignOpt = {\n    /**\n     * Gap open penalty (generally a negative number)\n     * @default -300|-400 set based on the sequence type\n     */\n    gapopen  : number,\n\n    /**\n     * Gap extend penalty (generally a negative number)\n     * @default -11|-60 set based on the sequence type\n     */\n    gapextend: number,\n\n    /**\n     * Set true to report debug information to the JS console\n     * @default false\n     */\n    debug    : boolean,\n\n    /**\n     * Alignment method. `auto` is the default value. For sequences length up\n     * to 1600 residues, a `complete` Needleman-Wunsch global alignment is\n     * performed. Beyond, a diagonal finding algorithm  (`diag`) is run first\n     * and global alignment is restricted to regions between diagonals.\n     * `complete` and `diag` parameters force the use of one of those\n     * strategies.\n     * @default 'auto'\n     */\n    method   : TAlignMethod,\n\n    /**\n     * Sequence type\n     * `auto` performs a detection based on sequences content\n     * @default 'auto'\n     */\n    type     : TAlignSequenceType,\n\n    /**\n     * Substitution scoring matrix. Residues are sorted lexically by their 1\n     * letter code (e.g. \"A, C, D, E...\" for proteins, not \"Ala, Arg, Asn,...\")\n     * which is a discrepancy with BLOSUM matrices found on NCBI.\n     * @default set based on sequence type\n     */\n    matrix   : number[][],\n\n    /**\n     * Char that is used as the symbol for gaps in sequences\n     * @default '-'\n     */\n    gapchar  : string\n}\n\ntype TBioMSAConfig = {\n    sequenceType: TAlignSequenceType,\n    gapchar: string,\n    alignmentMethod: TAlignMethod,\n    debug: boolean\n}\n\nconst DEFAULT_CONFIG: TBioMSAConfig = {\n    sequenceType: 'auto',\n    gapchar: DEFAULT_GAP_CHAR,\n    alignmentMethod: 'auto',\n    debug: false,\n}\n\nclass BioMSAClass {\n    private sequences: TSequence[] = [];\n    private typeSeq = SEQUENCE_TYPE.UNSET;\n    private config: TBioMSAConfig = {\n        ...DEFAULT_CONFIG\n    }\n\n    /**\n     * Add sequence to the internal list of sequences of the aligner.\n     * All sequences must be of same type.\n     * @param {(string|string[])} seq sequence or array of sequences to add\n     * @returns void\n     * @throws Will throw an exception if sequence added is not of same type as\n     *      the other internal sequences.\n     */\n    private addSequence(seq: string | string[]) {\n\n            // Handle Array parameter overload (recursive)\n\n        if (Array.isArray(seq)) {\n            seq.forEach((s) => {\n                this.addSequence(s);\n            });\n            return;\n        }\n\n            // Sanity checks\n\n        if (typeof seq !== 'string') {\n            throw new TypeError('String type expected for sequences to add.');\n        }\n        seq = seq.toUpperCase();\n\n            // In sequence type automatic detection mode, some checks are added\n            // to infer sequence type and sequence type consistency\n            // In user defined mode, we let the user do their own checks and we\n            // create the sequences eagerly (unrecognized residues are interpolated\n            // randomly)\n\n        if (this.config.sequenceType === 'auto') {\n            const type = getSequenceType(seq);\n\n                // First one\n\n            if (this.typeSeq === SEQUENCE_TYPE.UNSET) {\n                this.typeSeq = type;\n\n                // Once set, all the others must follow\n\n            } else if (this.typeSeq !== type) {\n                throw new Error('All sequences must be of same type.');\n            }\n        }\n\n            // Add sequence to store\n\n        this.sequences.push(makeSequence(seq));\n    }\n\n    /**\n     * Reset the internal sequence store content\n     */\n    private reset() {\n        this.sequences = [];\n        this.typeSeq = SEQUENCE_TYPE.UNSET;\n        this.setDefaultConfiguration();\n    }\n\n    private setDefaultConfiguration () {\n        this.config = {\n            ...DEFAULT_CONFIG\n        }\n    }\n\n    private setUserConfiguration (opt: Partial<TAlignOpt>) {\n        function isValid<K>(value: any, allowed: K[]) {\n            return (allowed.some(v => v == value));\n        }\n\n        if (\n            opt.method\n            && isValid<TAlignOpt['method']>(opt.method, ['complete', 'diag'])\n        ) this.config.alignmentMethod = opt.method;\n\n        if (\n            opt.type\n            && isValid<TAlignOpt['type']>(opt.type, ['amino', 'nucleic'])\n        ) {\n            this.config.sequenceType = opt.type;\n            this.typeSeq = (opt.type === 'amino') ? SEQUENCE_TYPE.PROTEIN : SEQUENCE_TYPE.NUCLEIC;\n        }\n\n        if (opt.gapchar?.length === 1) this.config.gapchar = opt.gapchar;\n\n        if (opt.debug !== undefined) this.config.debug = !!opt.debug;\n    }\n\n    /**\n     * Main alignment function. Takes an array of sequences (strings) as an\n     * argument or aligns sequences that were previously added to internal\n     * store.\n     * This function returns a promise.\n     * @param seqArr\n     * @returns { Promise<string[]> }\n     */\n    public align(seqArr: string[], opt?: Partial<TAlignOpt>) {\n        if (DEBUG) Log.start();\n\n        const msa = new Promise<string[]>((resolve, reject) => {\n\n                // Sequences prerequisites\n\n            if (!Array.isArray(seqArr)\n                || seqArr.some(v => typeof(v) !== 'string')\n            ) {\n                return reject('Array of sequences expected');\n            }\n\n            if (seqArr.length < 2) {\n                return reject('At least 2 sequences are required.');\n            }\n\n            this.reset();\n            if (opt) this.setUserConfiguration(opt);\n\n            this.addSequence(seqArr);\n\n            if (DEBUG) Log.add('Prepared sequences');\n\n            const lParam = getAlignmentParameters(this.typeSeq , opt);\n\n            if (DEBUG) Log.add('Get sequences type');\n\n                // Set heuristics used:\n                // if sequences are long and user does not dislike it, go for\n                // fast alignment.\n\n            let doNoAlign = false;\n            if (this.config.alignmentMethod === 'auto')\n                doNoAlign = this.sequences.some(seq => seq.rawSeq.length > 1600);\n            else doNoAlign = this.config.alignmentMethod === 'diag';\n\n                // Start alignment\n\n            let lEStrings: number[][];\n            if (this.sequences.length == 2) {\n\n                if (doNoAlign) {\n                    lEStrings = noalignPair(\n                        this.sequences[0],\n                        this.sequences[1],\n                        lParam\n                    );\n                } else {\n                    let lResult = pairwiseAlignment(\n                        this.sequences[0],\n                        this.sequences[1],\n                        lParam\n                    );\n                    lEStrings = lResult.estrings;\n                }\n\n            } else {\n\n                lEStrings = doNoAlign\n                    ? centerStarNoAlign(this.sequences, lParam)\n                    : progressiveAlignment(this.sequences, lParam);\n\n            }\n\n            if (DEBUG) Log.summary();\n\n            const lAlignment = applyEstring(this.sequences, lEStrings, { gapchar: this.config.gapchar });\n            return resolve(lAlignment);\n\n\n        })\n        .catch(err => {\n            // Finalize logs collected until this point\n            if (DEBUG) Log.summary();\n            return Promise.reject(err);\n        });\n\n        return msa;\n    }\n\n}\nconst BioMSA = new BioMSAClass();\nexport default BioMSA;\n"],"names":["hammingWeight","v","SEQUENCE_TYPE","length","setAll","this","_words","Uint32Array","BitArray","index","start","end","value","words","wordValue","wordStart","wordEnd","k","startWord","endWord","i","n","_assignRange","_i","indices","count","bs","_isRangeValue","otherBitarray","words1","words2","Math","min","size","wordsA","intersection","Object","create","prototype","callback","w","t","answer","Array","getSize","pos","toArray","join","sele","clone","VTML240","matrix","center","gapOP","BLASTZ","gapEP","regAmino","regExtNuc","regExtAmino","regNotRNA","regNotDNA","getSequenceType","seq","test","NUCLEIC","isExtendedNuc","isAmino","PROTEIN","SAMPLE_SIZE","lNucScore","LEN","SQRT1_2","guessSequenceType","Error","aaToNum","Uint8Array","fill","nucToNum","setRandomCode","letter","type","lRand","floor","random","compressToDayhoff","encodedSeq","map","val","toDayhoff","makeSequence","lType","encodedTab","convTable","lEncoding","imax","charCodeAt","encodeSeqToNum","rawSeq","compressedSeq","estringTransform","text","estring","opt","lPieces","GAPCHAR","gapchar","lPos","push","repeat","substr","estringProduct","estringB","estringA","lSteps","lPosA","lEstringA","slice","pushOperator","lValA","estringMerge","lEstring","j","lValB","sign","undefined","estringDifference","lCurVal","abs","estringCat","lRet","epath2estring","epath","lAcc","lVal","shift","reverse","estringLength","lSize","estringToIdx","lIdx","idx","pairwiseAlignment","seqA","seqB","params","sA","sB","lSeqALen","lSeqBLen","lMatch","lMatchArr","lDelArr","lPrevMatch","lLastInsert","tbIdx","isOdd","tbM","ceil","gapOpenA","gapOpenB","tb","scoringMatrix","GAP_OPEN","GAP_START_CORRECTION","GAP_END_CORRECTION","Infinity","score","max","_a","tracebBackToEpaths","lEpathA","lEpathB","estrings","lenA","lenB","tb0","lCurrentMatrix","NODE_TYPE","pSize","pAlphaSize","pNbSeq","pWeight","m_bAllGaps","m_uSortOrder","m_fcCounts","m_wCounts","Float32Array","m_AAScores","m_uResidueGroup","m_fOcc","m_fcStartOcc","m_fcEndOcc","m_ScoreGapOpen","m_ScoreGapClose","nbSeq","alphaSize","weight","ProfPos","id","ProfProxy","pProf","pIdx","prof","offset","get","set","clear","subarray","seqToProf","pSeq","lEncSeq","l","lProf","abSize","lGapO","lProx","getProxy","lResNb","col","setProxy","aaNum","mergeProfiles","pProfA","pProfB","pESA","pESB","console","log","lProxA","lProxB","lAidx","lBidx","lAi","lBi","lAiPrev","lBiPrev","lAisGapOpening","lAisGapClosing","lBisGapOpening","lBisGapClosing","lNbRes","isLeafNode","node","findMinInDistanceMatrix","tabIdx","minX","minY","profile","childA","childB","distance","msa","numSeq","NODE","depth","tabWeight","parent","recomputeDistMatrix","x","y","tI","lMax","lMin","averages","avg","splice","progressiveAlignment","pParam","order","lSorted","treeAlign","nodeA","tree","nodeB","result","lR","seqidx","lR_1","lProfALen","lGapOpenA","lGapOpenB","lPrevLastInsert","lDeletej_1","lInserti_1","lProfAGapOP","lProfAGapCP","lProfASScores","GAP_OPEN_B","GAP_CLOSE_B","GAP_START_CORRECTION_B","GAP_END_CORRECTION_B","profA","MSASeqAlignment","es","lR_2","lProfBLen","lGapExtendB","lProfAAAScores","lResList","lResProfNb","lOffset","kmax","GAP_START_FACTOR","profB","M0","MSAMSAAlignment","mD","tSeq","lNode","lMinX","lMinY","clusters","LEAF","toString","nbIterations","lChildA","lChildB","ROOT","makeTree","tabSeq","lKmerI","lSeqILen","lDistance","isProtein","alphabetSize","bitsetLength","pow","lKmer","bitset","seqAsNum","tupleval","topLetterFactor","distTab","getIntersectionSize","distanceMatrix","root","weights","cluster","tabWeights","totalWeight","setWeight","edgeLength","nbLeaves","split","clustalWeights","setProfiles","forEach","storeSize","store","head","tail","DEQueue","isEmpty","extractMinimizers","ksize","wsize","lMinzMap","Map","lQueue","lKSIZE","lKarr","Uint16Array","kval","lStartStore","lLength","lStoreMinz","kmer","kmerPos","winPos","winPosEnd","lCurrMinzPos","NaN","lWinStart","getTail","popTail","pushTail","getHead","popHead","lHead","lHeadKmer","lIdx_1","has","noalignPair","pAlignParam","pMinzA","pMinzB","lMinzAStore","lKmerAArr","_b","lMinzB","lMinzBStore","lKmerBArr","lDiagMap","listB","lMinzSubA","substring","lMinzSubB","lLen","lDiagId","lRange","indexOf","diagId","begin","lDiagList","diags","lCurrentSegment","range","sort","a","b","lDelta","pDiagList","pLenA","pLenB","lUnitPenalty","lDividerDiag","lIncreasingPaths","lTraceBack","Int16Array","lDiag","lDiagLen","lDiagBottomRow","lDiagTopRow","lDiagDistToEnd","lPathsScores","lPathsBottomRow","lPathsDistToEnd","lMinDiag","lMaxDiagId","lMaxDiag","lOptimumScore","lGCCount","lGarbageIdx","k_1","lPrevBottom","lRemainingDist","unshift","lGapPenalty","lNewSize","k_2","lPath","pop","lSafeguard","lLongestPath","extractLongestPath","lPrevSegment","lExtDiagList","lMissingSegments","m","endDiagId","beginDiagId","lWinScore","dnaHammingDistance","KSIZE","lMis","lResult","sanitizeEpathEnd","lEstringB","lEszA","lEszB","targetLength","lCount","estringCountPositive","c","DEFAULT_CONFIG","sequenceType","alignmentMethod","debug","UNSET","BioMSAClass","isArray","s","_this","addSequence","TypeError","toUpperCase","config","typeSeq","sequences","setDefaultConfiguration","isValid","allowed","some","method","seqArr","Promise","resolve","reject","reset","setUserConfiguration","lEStrings","lParam","pTypeSeq","lMatrix","lCenter","gapextend","row","gapopen","getAlignmentParameters","doNoAlign","lMinz","lCenterEString","lCenterEStringRaw","lEsAln","lDiff","error","dir","RangeError","centerStarNoAlign","pSeqArr","pEstring","lGapchar","lResp","applyEstring","catch","err"],"mappings":"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"}